return {
  Children = { {
      Children = { {
          Children = {},
          Properties = {
            ClassName = "ModuleScript",
            Name = "Promise",
            Source = "--[[\n\tAn implementation of Promises similar to Promise/A+.\n]]\n\nlocal ERROR_NON_PROMISE_IN_LIST = \"Non-promise value passed into %s at index %s\"\nlocal ERROR_NON_LIST = \"Please pass a list of promises to %s\"\nlocal ERROR_NON_FUNCTION = \"Please pass a handler function to %s!\"\nlocal MODE_KEY_METATABLE = { __mode = \"k\" }\n\nlocal function isCallable(value)\n\tif type(value) == \"function\" then\n\t\treturn true\n\tend\n\n\tif type(value) == \"table\" then\n\t\tlocal metatable = getmetatable(value)\n\t\tif metatable and type(rawget(metatable, \"__call\")) == \"function\" then\n\t\t\treturn true\n\t\tend\n\tend\n\n\treturn false\nend\n\n--[[\n\tCreates an enum dictionary with some metamethods to prevent common mistakes.\n]]\nlocal function makeEnum(enumName, members)\n\tlocal enum = {}\n\n\tfor _, memberName in ipairs(members) do\n\t\tenum[memberName] = memberName\n\tend\n\n\treturn setmetatable(enum, {\n\t\t__index = function(_, k)\n\t\t\terror(string.format(\"%s is not in %s!\", k, enumName), 2)\n\t\tend,\n\t\t__newindex = function()\n\t\t\terror(string.format(\"Creating new members in %s is not allowed!\", enumName), 2)\n\t\tend,\n\t})\nend\n\n--[=[\n\tAn object to represent runtime errors that occur during execution.\n\tPromises that experience an error like this will be rejected with\n\tan instance of this object.\n\n\t@class Error\n]=]\nlocal Error\ndo\n\tError = {\n\t\tKind = makeEnum(\"Promise.Error.Kind\", {\n\t\t\t\"ExecutionError\",\n\t\t\t\"AlreadyCancelled\",\n\t\t\t\"NotResolvedInTime\",\n\t\t\t\"TimedOut\",\n\t\t}),\n\t}\n\tError.__index = Error\n\n\tfunction Error.new(options, parent)\n\t\toptions = options or {}\n\t\treturn setmetatable({\n\t\t\terror = tostring(options.error) or \"[This error has no error text.]\",\n\t\t\ttrace = options.trace,\n\t\t\tcontext = options.context,\n\t\t\tkind = options.kind,\n\t\t\tparent = parent,\n\t\t\tcreatedTick = os.clock(),\n\t\t\tcreatedTrace = debug.traceback(),\n\t\t}, Error)\n\tend\n\n\tfunction Error.is(anything)\n\t\tif type(anything) == \"table\" then\n\t\t\tlocal metatable = getmetatable(anything)\n\n\t\t\tif type(metatable) == \"table\" then\n\t\t\t\treturn rawget(anything, \"error\") ~= nil and type(rawget(metatable, \"extend\")) == \"function\"\n\t\t\tend\n\t\tend\n\n\t\treturn false\n\tend\n\n\tfunction Error.isKind(anything, kind)\n\t\tassert(kind ~= nil, \"Argument #2 to Promise.Error.isKind must not be nil\")\n\n\t\treturn Error.is(anything) and anything.kind == kind\n\tend\n\n\tfunction Error:extend(options)\n\t\toptions = options or {}\n\n\t\toptions.kind = options.kind or self.kind\n\n\t\treturn Error.new(options, self)\n\tend\n\n\tfunction Error:getErrorChain()\n\t\tlocal runtimeErrors = { self }\n\n\t\twhile runtimeErrors[#runtimeErrors].parent do\n\t\t\ttable.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)\n\t\tend\n\n\t\treturn runtimeErrors\n\tend\n\n\tfunction Error:__tostring()\n\t\tlocal errorStrings = {\n\t\t\tstring.format(\"-- Promise.Error(%s) --\", self.kind or \"?\"),\n\t\t}\n\n\t\tfor _, runtimeError in ipairs(self:getErrorChain()) do\n\t\t\ttable.insert(\n\t\t\t\terrorStrings,\n\t\t\t\ttable.concat({\n\t\t\t\t\truntimeError.trace or runtimeError.error,\n\t\t\t\t\truntimeError.context,\n\t\t\t\t}, \"\\n\")\n\t\t\t)\n\t\tend\n\n\t\treturn table.concat(errorStrings, \"\\n\")\n\tend\nend\n\n--[[\n\tPacks a number of arguments into a table and returns its length.\n\n\tUsed to cajole varargs without dropping sparse values.\n]]\nlocal function pack(...)\n\treturn select(\"#\", ...), { ... }\nend\n\n--[[\n\tReturns first value (success), and packs all following values.\n]]\nlocal function packResult(success, ...)\n\treturn success, select(\"#\", ...), { ... }\nend\n\nlocal function makeErrorHandler(traceback)\n\tassert(traceback ~= nil, \"traceback is nil\")\n\n\treturn function(err)\n\t\t-- If the error object is already a table, forward it directly.\n\t\t-- Should we extend the error here and add our own trace?\n\n\t\tif type(err) == \"table\" then\n\t\t\treturn err\n\t\tend\n\n\t\treturn Error.new({\n\t\t\terror = err,\n\t\t\tkind = Error.Kind.ExecutionError,\n\t\t\ttrace = debug.traceback(tostring(err), 2),\n\t\t\tcontext = \"Promise created at:\\n\\n\" .. traceback,\n\t\t})\n\tend\nend\n\n--[[\n\tCalls a Promise executor with error handling.\n]]\nlocal function runExecutor(traceback, callback, ...)\n\treturn packResult(xpcall(callback, makeErrorHandler(traceback), ...))\nend\n\n--[[\n\tCreates a function that invokes a callback with correct error handling and\n\tresolution mechanisms.\n]]\nlocal function createAdvancer(traceback, callback, resolve, reject)\n\treturn function(...)\n\t\tlocal ok, resultLength, result = runExecutor(traceback, callback, ...)\n\n\t\tif ok then\n\t\t\tresolve(unpack(result, 1, resultLength))\n\t\telse\n\t\t\treject(result[1])\n\t\tend\n\tend\nend\n\nlocal function isEmpty(t)\n\treturn next(t) == nil\nend\n\n--[=[\n\tAn enum value used to represent the Promise's status.\n\t@interface Status\n\t@tag enum\n\t@within Promise\n\t.Started \"Started\" -- The Promise is executing, and not settled yet.\n\t.Resolved \"Resolved\" -- The Promise finished successfully.\n\t.Rejected \"Rejected\" -- The Promise was rejected.\n\t.Cancelled \"Cancelled\" -- The Promise was cancelled before it finished.\n]=]\n--[=[\n\t@prop Status Status\n\t@within Promise\n\t@readonly\n\t@tag enums\n\tA table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.\n]=]\n--[=[\n\tA Promise is an object that represents a value that will exist in the future, but doesn't right now.\n\tPromises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),\n\tor if an error has occurred (known as *rejecting*).\n\n\t@class Promise\n\t@__index prototype\n]=]\nlocal Promise = {\n\tError = Error,\n\tStatus = makeEnum(\"Promise.Status\", { \"Started\", \"Resolved\", \"Rejected\", \"Cancelled\" }),\n\t_getTime = os.clock,\n\t_timeEvent = game:GetService(\"RunService\").Heartbeat,\n\t_unhandledRejectionCallbacks = {},\n}\nPromise.prototype = {}\nPromise.__index = Promise.prototype\n\nfunction Promise._new(traceback, callback, parent)\n\tif parent ~= nil and not Promise.is(parent) then\n\t\terror(\"Argument #2 to Promise.new must be a promise or nil\", 2)\n\tend\n\n\tlocal self = {\n\t\t-- Used to locate where a promise was created\n\t\t_source = traceback,\n\n\t\t_status = Promise.Status.Started,\n\n\t\t-- A table containing a list of all results, whether success or failure.\n\t\t-- Only valid if _status is set to something besides Started\n\t\t_values = nil,\n\n\t\t-- Lua doesn't like sparse arrays very much, so we explicitly store the\n\t\t-- length of _values to handle middle nils.\n\t\t_valuesLength = -1,\n\n\t\t-- Tracks if this Promise has no error observers..\n\t\t_unhandledRejection = true,\n\n\t\t-- Queues representing functions we should invoke when we update!\n\t\t_queuedResolve = {},\n\t\t_queuedReject = {},\n\t\t_queuedFinally = {},\n\n\t\t-- The function to run when/if this promise is cancelled.\n\t\t_cancellationHook = nil,\n\n\t\t-- The \"parent\" of this promise in a promise chain. Required for\n\t\t-- cancellation propagation upstream.\n\t\t_parent = parent,\n\n\t\t-- Consumers are Promises that have chained onto this one.\n\t\t-- We track them for cancellation propagation downstream.\n\t\t_consumers = setmetatable({}, MODE_KEY_METATABLE),\n\t}\n\n\tif parent and parent._status == Promise.Status.Started then\n\t\tparent._consumers[self] = true\n\tend\n\n\tsetmetatable(self, Promise)\n\n\tlocal function resolve(...)\n\t\tself:_resolve(...)\n\tend\n\n\tlocal function reject(...)\n\t\tself:_reject(...)\n\tend\n\n\tlocal function onCancel(cancellationHook)\n\t\tif cancellationHook then\n\t\t\tif self._status == Promise.Status.Cancelled then\n\t\t\t\tcancellationHook()\n\t\t\telse\n\t\t\t\tself._cancellationHook = cancellationHook\n\t\t\tend\n\t\tend\n\n\t\treturn self._status == Promise.Status.Cancelled\n\tend\n\n\tcoroutine.wrap(function()\n\t\tlocal ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)\n\n\t\tif not ok then\n\t\t\treject(result[1])\n\t\tend\n\tend)()\n\n\treturn self\nend\n\n--[=[\n\tConstruct a new Promise that will be resolved or rejected with the given callbacks.\n\n\tIf you `resolve` with a Promise, it will be chained onto.\n\n\tYou can safely yield within the executor function and it will not block the creating thread.\n\n\t```lua\n\tlocal myFunction()\n\t\treturn Promise.new(function(resolve, reject, onCancel)\n\t\t\twait(1)\n\t\t\tresolve(\"Hello world!\")\n\t\tend)\n\tend\n\n\tmyFunction():andThen(print)\n\t```\n\n\tYou do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.\n\n\tYou may register an optional cancellation hook by using the `onCancel` argument:\n\n\t* This should be used to abort any ongoing operations leading up to the promise being settled.\n\t* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.\n\t* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.\n\t* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.\n\t* You can set the cancellation hook at any time before resolving.\n\t* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.\n\n\t@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()\n\t@return Promise\n]=]\nfunction Promise.new(executor)\n\treturn Promise._new(debug.traceback(nil, 2), executor)\nend\n\nfunction Promise:__tostring()\n\treturn string.format(\"Promise(%s)\", self._status)\nend\n\n--[=[\n\tThe same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.\n\n\tThis is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.\n\n\t```lua\n\tlocal function waitForChild(instance, childName, timeout)\n\t  return Promise.defer(function(resolve, reject)\n\t\tlocal child = instance:WaitForChild(childName, timeout)\n\n\t\t;(child and resolve or reject)(child)\n\t  end)\n\tend\n\t```\n\n\t@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()\n\t@return Promise\n]=]\nfunction Promise.defer(executor)\n\tlocal traceback = debug.traceback(nil, 2)\n\tlocal promise\n\tpromise = Promise._new(traceback, function(resolve, reject, onCancel)\n\t\tlocal connection\n\t\tconnection = Promise._timeEvent:Connect(function()\n\t\t\tconnection:Disconnect()\n\t\t\tlocal ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)\n\n\t\t\tif not ok then\n\t\t\t\treject(result[1])\n\t\t\tend\n\t\tend)\n\tend)\n\n\treturn promise\nend\n\n-- Backwards compatibility\nPromise.async = Promise.defer\n\n--[=[\n\tCreates an immediately resolved Promise with the given value.\n\n\t```lua\n\t-- Example using Promise.resolve to deliver cached values:\n\tfunction getSomething(name)\n\t\tif cache[name] then\n\t\t\treturn Promise.resolve(cache[name])\n\t\telse\n\t\t\treturn Promise.new(function(resolve, reject)\n\t\t\t\tlocal thing = getTheThing()\n\t\t\t\tcache[name] = thing\n\n\t\t\t\tresolve(thing)\n\t\t\tend)\n\t\tend\n\tend\n\t```\n\n\t@param ... any\n\t@return Promise<...any>\n]=]\nfunction Promise.resolve(...)\n\tlocal length, values = pack(...)\n\treturn Promise._new(debug.traceback(nil, 2), function(resolve)\n\t\tresolve(unpack(values, 1, length))\n\tend)\nend\n\n--[=[\n\tCreates an immediately rejected Promise with the given value.\n\n\t:::caution\n\tSomething needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.\n\t:::\n\n\t@param ... any\n\t@return Promise<...any>\n]=]\nfunction Promise.reject(...)\n\tlocal length, values = pack(...)\n\treturn Promise._new(debug.traceback(nil, 2), function(_, reject)\n\t\treject(unpack(values, 1, length))\n\tend)\nend\n\n--[[\n\tRuns a non-promise-returning function as a Promise with the\n  given arguments.\n]]\nfunction Promise._try(traceback, callback, ...)\n\tlocal valuesLength, values = pack(...)\n\n\treturn Promise._new(traceback, function(resolve)\n\t\tresolve(callback(unpack(values, 1, valuesLength)))\n\tend)\nend\n\n--[=[\n\tBegins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.\n\n\t:::info\n\t`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.\n\t:::\n\n\t```lua\n\tPromise.try(function()\n\t\treturn math.random(1, 2) == 1 and \"ok\" or error(\"Oh an error!\")\n\tend)\n\t\t:andThen(function(text)\n\t\t\tprint(text)\n\t\tend)\n\t\t:catch(function(err)\n\t\t\twarn(\"Something went wrong\")\n\t\tend)\n\t```\n\n\t@param callback (...: T...) -> ...any\n\t@param ... T... -- Additional arguments passed to `callback`\n\t@return Promise\n]=]\nfunction Promise.try(callback, ...)\n\treturn Promise._try(debug.traceback(nil, 2), callback, ...)\nend\n\n--[[\n\tReturns a new promise that:\n\t\t* is resolved when all input promises resolve\n\t\t* is rejected if ANY input promises reject\n]]\nfunction Promise._all(traceback, promises, amount)\n\tif type(promises) ~= \"table\" then\n\t\terror(string.format(ERROR_NON_LIST, \"Promise.all\"), 3)\n\tend\n\n\t-- We need to check that each value is a promise here so that we can produce\n\t-- a proper error rather than a rejected promise with our error.\n\tfor i, promise in pairs(promises) do\n\t\tif not Promise.is(promise) then\n\t\t\terror(string.format(ERROR_NON_PROMISE_IN_LIST, \"Promise.all\", tostring(i)), 3)\n\t\tend\n\tend\n\n\t-- If there are no values then return an already resolved promise.\n\tif #promises == 0 or amount == 0 then\n\t\treturn Promise.resolve({})\n\tend\n\n\treturn Promise._new(traceback, function(resolve, reject, onCancel)\n\t\t-- An array to contain our resolved values from the given promises.\n\t\tlocal resolvedValues = {}\n\t\tlocal newPromises = {}\n\n\t\t-- Keep a count of resolved promises because just checking the resolved\n\t\t-- values length wouldn't account for promises that resolve with nil.\n\t\tlocal resolvedCount = 0\n\t\tlocal rejectedCount = 0\n\t\tlocal done = false\n\n\t\tlocal function cancel()\n\t\t\tfor _, promise in ipairs(newPromises) do\n\t\t\t\tpromise:cancel()\n\t\t\tend\n\t\tend\n\n\t\t-- Called when a single value is resolved and resolves if all are done.\n\t\tlocal function resolveOne(i, ...)\n\t\t\tif done then\n\t\t\t\treturn\n\t\t\tend\n\n\t\t\tresolvedCount = resolvedCount + 1\n\n\t\t\tif amount == nil then\n\t\t\t\tresolvedValues[i] = ...\n\t\t\telse\n\t\t\t\tresolvedValues[resolvedCount] = ...\n\t\t\tend\n\n\t\t\tif resolvedCount >= (amount or #promises) then\n\t\t\t\tdone = true\n\t\t\t\tresolve(resolvedValues)\n\t\t\t\tcancel()\n\t\t\tend\n\t\tend\n\n\t\tonCancel(cancel)\n\n\t\t-- We can assume the values inside `promises` are all promises since we\n\t\t-- checked above.\n\t\tfor i, promise in ipairs(promises) do\n\t\t\tnewPromises[i] = promise:andThen(function(...)\n\t\t\t\tresolveOne(i, ...)\n\t\t\tend, function(...)\n\t\t\t\trejectedCount = rejectedCount + 1\n\n\t\t\t\tif amount == nil or #promises - rejectedCount < amount then\n\t\t\t\t\tcancel()\n\t\t\t\t\tdone = true\n\n\t\t\t\t\treject(...)\n\t\t\t\tend\n\t\t\tend)\n\t\tend\n\n\t\tif done then\n\t\t\tcancel()\n\t\tend\n\tend)\nend\n\n--[=[\n\tAccepts an array of Promises and returns a new promise that:\n\t* is resolved after all input promises resolve.\n\t* is rejected if *any* input promises reject.\n\n\t:::info\n\tOnly the first return value from each promise will be present in the resulting array.\n\t:::\n\n\tAfter any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.\n\n\t```lua\n\tlocal promises = {\n\t\treturnsAPromise(\"example 1\"),\n\t\treturnsAPromise(\"example 2\"),\n\t\treturnsAPromise(\"example 3\"),\n\t}\n\n\treturn Promise.all(promises)\n\t```\n\n\t@param promises {Promise<T>}\n\t@return Promise<{T}>\n]=]\nfunction Promise.all(promises)\n\treturn Promise._all(debug.traceback(nil, 2), promises)\nend\n\n--[=[\n\tFolds an array of values or promises into a single value. The array is traversed sequentially.\n\n\tThe reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.\n\n\tThe folding will stop at the first rejection encountered.\n\t```lua\n\tlocal basket = {\"blueberry\", \"melon\", \"pear\", \"melon\"}\n\tPromise.fold(basket, function(cost, fruit)\n\t\tif fruit == \"blueberry\" then\n\t\t\treturn cost -- blueberries are free!\n\t\telse\n\t\t\t-- call a function that returns a promise with the fruit price\n\t\t\treturn fetchPrice(fruit):andThen(function(fruitCost)\n\t\t\t\treturn cost + fruitCost\n\t\t\tend)\n\t\tend\n\tend, 0)\n\t```\n\n\t@since v3.1.0\n\t@param list {T | Promise<T>}\n\t@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>\n\t@param initialValue U\n]=]\nfunction Promise.fold(list, reducer, initialValue)\n\tassert(type(list) == \"table\", \"Bad argument #1 to Promise.fold: must be a table\")\n\tassert(isCallable(reducer), \"Bad argument #2 to Promise.fold: must be a function\")\n\n\tlocal accumulator = Promise.resolve(initialValue)\n\treturn Promise.each(list, function(resolvedElement, i)\n\t\taccumulator = accumulator:andThen(function(previousValueResolved)\n\t\t\treturn reducer(previousValueResolved, resolvedElement, i)\n\t\tend)\n\tend):andThen(function()\n\t\treturn accumulator\n\tend)\nend\n\n--[=[\n\tAccepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.\n\n\t`count` 0 results in an empty array. The resultant array will never have more than `count` elements.\n\n\t```lua\n\tlocal promises = {\n\t\treturnsAPromise(\"example 1\"),\n\t\treturnsAPromise(\"example 2\"),\n\t\treturnsAPromise(\"example 3\"),\n\t}\n\n\treturn Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve\n\t```\n\n\t@param promises {Promise<T>}\n\t@param count number\n\t@return Promise<{T}>\n]=]\nfunction Promise.some(promises, count)\n\tassert(type(count) == \"number\", \"Bad argument #2 to Promise.some: must be a number\")\n\n\treturn Promise._all(debug.traceback(nil, 2), promises, count)\nend\n\n--[=[\n\tAccepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.\n\n\tResolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.\n\n\t```lua\n\tlocal promises = {\n\t\treturnsAPromise(\"example 1\"),\n\t\treturnsAPromise(\"example 2\"),\n\t\treturnsAPromise(\"example 3\"),\n\t}\n\n\treturn Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)\n\t```\n\n\t@param promises {Promise<T>}\n\t@return Promise<T>\n]=]\nfunction Promise.any(promises)\n\treturn Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)\n\t\treturn values[1]\n\tend)\nend\n\n--[=[\n\tAccepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.\n\n\t```lua\n\tlocal promises = {\n\t\treturnsAPromise(\"example 1\"),\n\t\treturnsAPromise(\"example 2\"),\n\t\treturnsAPromise(\"example 3\"),\n\t}\n\n\treturn Promise.allSettled(promises)\n\t```\n\n\t@param promises {Promise<T>}\n\t@return Promise<{Status}>\n]=]\nfunction Promise.allSettled(promises)\n\tif type(promises) ~= \"table\" then\n\t\terror(string.format(ERROR_NON_LIST, \"Promise.allSettled\"), 2)\n\tend\n\n\t-- We need to check that each value is a promise here so that we can produce\n\t-- a proper error rather than a rejected promise with our error.\n\tfor i, promise in pairs(promises) do\n\t\tif not Promise.is(promise) then\n\t\t\terror(string.format(ERROR_NON_PROMISE_IN_LIST, \"Promise.allSettled\", tostring(i)), 2)\n\t\tend\n\tend\n\n\t-- If there are no values then return an already resolved promise.\n\tif #promises == 0 then\n\t\treturn Promise.resolve({})\n\tend\n\n\treturn Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)\n\t\t-- An array to contain our resolved values from the given promises.\n\t\tlocal fates = {}\n\t\tlocal newPromises = {}\n\n\t\t-- Keep a count of resolved promises because just checking the resolved\n\t\t-- values length wouldn't account for promises that resolve with nil.\n\t\tlocal finishedCount = 0\n\n\t\t-- Called when a single value is resolved and resolves if all are done.\n\t\tlocal function resolveOne(i, ...)\n\t\t\tfinishedCount = finishedCount + 1\n\n\t\t\tfates[i] = ...\n\n\t\t\tif finishedCount >= #promises then\n\t\t\t\tresolve(fates)\n\t\t\tend\n\t\tend\n\n\t\tonCancel(function()\n\t\t\tfor _, promise in ipairs(newPromises) do\n\t\t\t\tpromise:cancel()\n\t\t\tend\n\t\tend)\n\n\t\t-- We can assume the values inside `promises` are all promises since we\n\t\t-- checked above.\n\t\tfor i, promise in ipairs(promises) do\n\t\t\tnewPromises[i] = promise:finally(function(...)\n\t\t\t\tresolveOne(i, ...)\n\t\t\tend)\n\t\tend\n\tend)\nend\n\n--[=[\n\tAccepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.\n\n\t:::warning\n\tIf the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.\n\n\tIf you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.\n\t:::\n\n\tAll other Promises that don't win the race will be cancelled if they have no other consumers.\n\n\t```lua\n\tlocal promises = {\n\t\treturnsAPromise(\"example 1\"),\n\t\treturnsAPromise(\"example 2\"),\n\t\treturnsAPromise(\"example 3\"),\n\t}\n\n\treturn Promise.race(promises) -- Only returns 1st value to resolve or reject\n\t```\n\n\t@param promises {Promise<T>}\n\t@return Promise<T>\n]=]\nfunction Promise.race(promises)\n\tassert(type(promises) == \"table\", string.format(ERROR_NON_LIST, \"Promise.race\"))\n\n\tfor i, promise in pairs(promises) do\n\t\tassert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, \"Promise.race\", tostring(i)))\n\tend\n\n\treturn Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)\n\t\tlocal newPromises = {}\n\t\tlocal finished = false\n\n\t\tlocal function cancel()\n\t\t\tfor _, promise in ipairs(newPromises) do\n\t\t\t\tpromise:cancel()\n\t\t\tend\n\t\tend\n\n\t\tlocal function finalize(callback)\n\t\t\treturn function(...)\n\t\t\t\tcancel()\n\t\t\t\tfinished = true\n\t\t\t\treturn callback(...)\n\t\t\tend\n\t\tend\n\n\t\tif onCancel(finalize(reject)) then\n\t\t\treturn\n\t\tend\n\n\t\tfor i, promise in ipairs(promises) do\n\t\t\tnewPromises[i] = promise:andThen(finalize(resolve), finalize(reject))\n\t\tend\n\n\t\tif finished then\n\t\t\tcancel()\n\t\tend\n\tend)\nend\n\n--[=[\n\tIterates serially over the given an array of values, calling the predicate callback on each value before continuing.\n\n\tIf the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item\n\tin the array.\n\n\t:::info\n\t`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.\n\n\tBut because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.\n\n\tThe predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.\n\t:::\n\n\t```lua\n\tPromise.each({\n\t\t\"foo\",\n\t\t\"bar\",\n\t\t\"baz\",\n\t\t\"qux\"\n\t}, function(value, index)\n\t\treturn Promise.delay(1):andThen(function()\n\t\tprint((\"%d) Got %s!\"):format(index, value))\n\t\tend)\n\tend)\n\n\t--[[\n\t\t(1 second passes)\n\t\t> 1) Got foo!\n\t\t(1 second passes)\n\t\t> 2) Got bar!\n\t\t(1 second passes)\n\t\t> 3) Got baz!\n\t\t(1 second passes)\n\t\t> 4) Got qux!\n\t]]\n\t```\n\n\tIf the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.\n\n\tIf the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.\n\n\tIf a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.\n\n\tReturns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.\n\n\tIf this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:\n\t- Iteration will not continue.\n\t- Any Promises within the array of values will now be cancelled if they have no other consumers.\n\t- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.\n\n\t@since 3.0.0\n\t@param list {T | Promise<T>}\n\t@param predicate (value: T, index: number) -> U | Promise<U>\n\t@return Promise<{U}>\n]=]\nfunction Promise.each(list, predicate)\n\tassert(type(list) == \"table\", string.format(ERROR_NON_LIST, \"Promise.each\"))\n\tassert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, \"Promise.each\"))\n\n\treturn Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)\n\t\tlocal results = {}\n\t\tlocal promisesToCancel = {}\n\n\t\tlocal cancelled = false\n\n\t\tlocal function cancel()\n\t\t\tfor _, promiseToCancel in ipairs(promisesToCancel) do\n\t\t\t\tpromiseToCancel:cancel()\n\t\t\tend\n\t\tend\n\n\t\tonCancel(function()\n\t\t\tcancelled = true\n\n\t\t\tcancel()\n\t\tend)\n\n\t\t-- We need to preprocess the list of values and look for Promises.\n\t\t-- If we find some, we must register our andThen calls now, so that those Promises have a consumer\n\t\t-- from us registered. If we don't do this, those Promises might get cancelled by something else\n\t\t-- before we get to them in the series because it's not possible to tell that we plan to use it\n\t\t-- unless we indicate it here.\n\n\t\tlocal preprocessedList = {}\n\n\t\tfor index, value in ipairs(list) do\n\t\t\tif Promise.is(value) then\n\t\t\t\tif value:getStatus() == Promise.Status.Cancelled then\n\t\t\t\t\tcancel()\n\t\t\t\t\treturn reject(Error.new({\n\t\t\t\t\t\terror = \"Promise is cancelled\",\n\t\t\t\t\t\tkind = Error.Kind.AlreadyCancelled,\n\t\t\t\t\t\tcontext = string.format(\n\t\t\t\t\t\t\t\"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\\n\\nThat Promise was created at:\\n\\n%s\",\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\tvalue._source\n\t\t\t\t\t\t),\n\t\t\t\t\t}))\n\t\t\t\telseif value:getStatus() == Promise.Status.Rejected then\n\t\t\t\t\tcancel()\n\t\t\t\t\treturn reject(select(2, value:await()))\n\t\t\t\tend\n\n\t\t\t\t-- Chain a new Promise from this one so we only cancel ours\n\t\t\t\tlocal ourPromise = value:andThen(function(...)\n\t\t\t\t\treturn ...\n\t\t\t\tend)\n\n\t\t\t\ttable.insert(promisesToCancel, ourPromise)\n\t\t\t\tpreprocessedList[index] = ourPromise\n\t\t\telse\n\t\t\t\tpreprocessedList[index] = value\n\t\t\tend\n\t\tend\n\n\t\tfor index, value in ipairs(preprocessedList) do\n\t\t\tif Promise.is(value) then\n\t\t\t\tlocal success\n\t\t\t\tsuccess, value = value:await()\n\n\t\t\t\tif not success then\n\t\t\t\t\tcancel()\n\t\t\t\t\treturn reject(value)\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tif cancelled then\n\t\t\t\treturn\n\t\t\tend\n\n\t\t\tlocal predicatePromise = Promise.resolve(predicate(value, index))\n\n\t\t\ttable.insert(promisesToCancel, predicatePromise)\n\n\t\t\tlocal success, result = predicatePromise:await()\n\n\t\t\tif not success then\n\t\t\t\tcancel()\n\t\t\t\treturn reject(result)\n\t\t\tend\n\n\t\t\tresults[index] = result\n\t\tend\n\n\t\tresolve(results)\n\tend)\nend\n\n--[=[\n\tChecks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.\n\n\t@param object any\n\t@return boolean -- `true` if the given `object` is a Promise.\n]=]\nfunction Promise.is(object)\n\tif type(object) ~= \"table\" then\n\t\treturn false\n\tend\n\n\tlocal objectMetatable = getmetatable(object)\n\n\tif objectMetatable == Promise then\n\t\t-- The Promise came from this library.\n\t\treturn true\n\telseif objectMetatable == nil then\n\t\t-- No metatable, but we should still chain onto tables with andThen methods\n\t\treturn isCallable(object.andThen)\n\telseif\n\t\ttype(objectMetatable) == \"table\"\n\t\tand type(rawget(objectMetatable, \"__index\")) == \"table\"\n\t\tand isCallable(rawget(rawget(objectMetatable, \"__index\"), \"andThen\"))\n\tthen\n\t\t-- Maybe this came from a different or older Promise library.\n\t\treturn true\n\tend\n\n\treturn false\nend\n\n--[=[\n\tWraps a function that yields into one that returns a Promise.\n\n\tAny errors that occur while executing the function will be turned into rejections.\n\n\t:::info\n\t`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.\n\t:::\n\n\t```lua\n\tlocal sleep = Promise.promisify(wait)\n\n\tsleep(1):andThen(print)\n\t```\n\n\t```lua\n\tlocal isPlayerInGroup = Promise.promisify(function(player, groupId)\n\t\treturn player:IsInGroup(groupId)\n\tend)\n\t```\n\n\t@param callback (...: any) -> ...any\n\t@return (...: any) -> Promise\n]=]\nfunction Promise.promisify(callback)\n\treturn function(...)\n\t\treturn Promise._try(debug.traceback(nil, 2), callback, ...)\n\tend\nend\n\n--[=[\n\tReturns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.\n\n\tThis function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.\n\n\t:::warning\n\tPassing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.\n\t:::\n\n\t```lua\n\t\tPromise.delay(5):andThenCall(print, \"This prints after 5 seconds\")\n\t```\n\n\t@function delay\n\t@within Promise\n\t@param seconds number\n\t@return Promise<number>\n]=]\ndo\n\t-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert\n\n\t-- the initial node in the linked list\n\tlocal first\n\tlocal connection\n\n\tfunction Promise.delay(seconds)\n\t\tassert(type(seconds) == \"number\", \"Bad argument #1 to Promise.delay, must be a number.\")\n\t\t-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.\n\t\t-- This mirrors the behavior of wait()\n\t\tif not (seconds >= 1 / 60) or seconds == math.huge then\n\t\t\tseconds = 1 / 60\n\t\tend\n\n\t\treturn Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)\n\t\t\tlocal startTime = Promise._getTime()\n\t\t\tlocal endTime = startTime + seconds\n\n\t\t\tlocal node = {\n\t\t\t\tresolve = resolve,\n\t\t\t\tstartTime = startTime,\n\t\t\t\tendTime = endTime,\n\t\t\t}\n\n\t\t\tif connection == nil then -- first is nil when connection is nil\n\t\t\t\tfirst = node\n\t\t\t\tconnection = Promise._timeEvent:Connect(function()\n\t\t\t\t\tlocal threadStart = Promise._getTime()\n\n\t\t\t\t\twhile first ~= nil and first.endTime < threadStart do\n\t\t\t\t\t\tlocal current = first\n\t\t\t\t\t\tfirst = current.next\n\n\t\t\t\t\t\tif first == nil then\n\t\t\t\t\t\t\tconnection:Disconnect()\n\t\t\t\t\t\t\tconnection = nil\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfirst.previous = nil\n\t\t\t\t\t\tend\n\n\t\t\t\t\t\tcurrent.resolve(Promise._getTime() - current.startTime)\n\t\t\t\t\tend\n\t\t\t\tend)\n\t\t\telse -- first is non-nil\n\t\t\t\tif first.endTime < endTime then -- if `node` should be placed after `first`\n\t\t\t\t\t-- we will insert `node` between `current` and `next`\n\t\t\t\t\t-- (i.e. after `current` if `next` is nil)\n\t\t\t\t\tlocal current = first\n\t\t\t\t\tlocal next = current.next\n\n\t\t\t\t\twhile next ~= nil and next.endTime < endTime do\n\t\t\t\t\t\tcurrent = next\n\t\t\t\t\t\tnext = current.next\n\t\t\t\t\tend\n\n\t\t\t\t\t-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)\n\t\t\t\t\tcurrent.next = node\n\t\t\t\t\tnode.previous = current\n\n\t\t\t\t\tif next ~= nil then\n\t\t\t\t\t\tnode.next = next\n\t\t\t\t\t\tnext.previous = node\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\t-- set `node` to `first`\n\t\t\t\t\tnode.next = first\n\t\t\t\t\tfirst.previous = node\n\t\t\t\t\tfirst = node\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tonCancel(function()\n\t\t\t\t-- remove node from queue\n\t\t\t\tlocal next = node.next\n\n\t\t\t\tif first == node then\n\t\t\t\t\tif next == nil then -- if `node` is the first and last\n\t\t\t\t\t\tconnection:Disconnect()\n\t\t\t\t\t\tconnection = nil\n\t\t\t\t\telse -- if `node` is `first` and not the last\n\t\t\t\t\t\tnext.previous = nil\n\t\t\t\t\tend\n\t\t\t\t\tfirst = next\n\t\t\t\telse\n\t\t\t\t\tlocal previous = node.previous\n\t\t\t\t\t-- since `node` is not `first`, then we know `previous` is non-nil\n\t\t\t\t\tprevious.next = next\n\n\t\t\t\t\tif next ~= nil then\n\t\t\t\t\t\tnext.previous = previous\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend)\n\t\tend)\n\tend\nend\n\n--[=[\n\tReturns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.\n\n\tRejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].\n\n\t```lua\n\tgetSomething():timeout(5):andThen(function(something)\n\t\t-- got something and it only took at max 5 seconds\n\tend):catch(function(e)\n\t\t-- Either getting something failed or the time was exceeded.\n\n\t\tif Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then\n\t\t\twarn(\"Operation timed out!\")\n\t\telse\n\t\t\twarn(\"Operation encountered an error!\")\n\t\tend\n\tend)\n\t```\n\n\tSugar for:\n\n\t```lua\n\tPromise.race({\n\t\tPromise.delay(seconds):andThen(function()\n\t\t\treturn Promise.reject(\n\t\t\t\trejectionValue == nil\n\t\t\t\tand Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })\n\t\t\t\tor rejectionValue\n\t\t\t)\n\t\tend),\n\t\tpromise\n\t})\n\t```\n\n\t@param seconds number\n\t@param rejectionValue? any -- The value to reject with if the timeout is reached\n\t@return Promise\n]=]\nfunction Promise.prototype:timeout(seconds, rejectionValue)\n\tlocal traceback = debug.traceback(nil, 2)\n\n\treturn Promise.race({\n\t\tPromise.delay(seconds):andThen(function()\n\t\t\treturn Promise.reject(rejectionValue == nil and Error.new({\n\t\t\t\tkind = Error.Kind.TimedOut,\n\t\t\t\terror = \"Timed out\",\n\t\t\t\tcontext = string.format(\n\t\t\t\t\t\"Timeout of %d seconds exceeded.\\n:timeout() called at:\\n\\n%s\",\n\t\t\t\t\tseconds,\n\t\t\t\t\ttraceback\n\t\t\t\t),\n\t\t\t}) or rejectionValue)\n\t\tend),\n\t\tself,\n\t})\nend\n\n--[=[\n\tReturns the current Promise status.\n\n\t@return Status\n]=]\nfunction Promise.prototype:getStatus()\n\treturn self._status\nend\n\n--[[\n\tCreates a new promise that receives the result of this promise.\n\n\tThe given callbacks are invoked depending on that result.\n]]\nfunction Promise.prototype:_andThen(traceback, successHandler, failureHandler)\n\tself._unhandledRejection = false\n\n\t-- Create a new promise to follow this part of the chain\n\treturn Promise._new(traceback, function(resolve, reject)\n\t\t-- Our default callbacks just pass values onto the next promise.\n\t\t-- This lets success and failure cascade correctly!\n\n\t\tlocal successCallback = resolve\n\t\tif successHandler then\n\t\t\tsuccessCallback = createAdvancer(traceback, successHandler, resolve, reject)\n\t\tend\n\n\t\tlocal failureCallback = reject\n\t\tif failureHandler then\n\t\t\tfailureCallback = createAdvancer(traceback, failureHandler, resolve, reject)\n\t\tend\n\n\t\tif self._status == Promise.Status.Started then\n\t\t\t-- If we haven't resolved yet, put ourselves into the queue\n\t\t\ttable.insert(self._queuedResolve, successCallback)\n\t\t\ttable.insert(self._queuedReject, failureCallback)\n\t\telseif self._status == Promise.Status.Resolved then\n\t\t\t-- This promise has already resolved! Trigger success immediately.\n\t\t\tsuccessCallback(unpack(self._values, 1, self._valuesLength))\n\t\telseif self._status == Promise.Status.Rejected then\n\t\t\t-- This promise died a terrible death! Trigger failure immediately.\n\t\t\tfailureCallback(unpack(self._values, 1, self._valuesLength))\n\t\telseif self._status == Promise.Status.Cancelled then\n\t\t\t-- We don't want to call the success handler or the failure handler,\n\t\t\t-- we just reject this promise outright.\n\t\t\treject(Error.new({\n\t\t\t\terror = \"Promise is cancelled\",\n\t\t\t\tkind = Error.Kind.AlreadyCancelled,\n\t\t\t\tcontext = \"Promise created at\\n\\n\" .. traceback,\n\t\t\t}))\n\t\tend\n\tend, self)\nend\n\n--[=[\n\tChains onto an existing Promise and returns a new Promise.\n\n\t:::warning\n\tWithin the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.\n\t:::\n\n\tReturn a Promise from the success or failure handler and it will be chained onto.\n\n\t@param successHandler (...: any) -> ...any\n\t@param failureHandler? (...: any) -> ...any\n\t@return Promise<...any>\n]=]\nfunction Promise.prototype:andThen(successHandler, failureHandler)\n\tassert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, \"Promise:andThen\"))\n\tassert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, \"Promise:andThen\"))\n\n\treturn self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)\nend\n\n--[=[\n\tShorthand for `Promise:andThen(nil, failureHandler)`.\n\n\tReturns a Promise that resolves if the `failureHandler` worked without encountering an additional error.\n\n\t:::warning\n\tWithin the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.\n\t:::\n\n\n\t@param failureHandler (...: any) -> ...any\n\t@return Promise<...any>\n]=]\nfunction Promise.prototype:catch(failureHandler)\n\tassert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, \"Promise:catch\"))\n\treturn self:_andThen(debug.traceback(nil, 2), nil, failureHandler)\nend\n\n--[=[\n\tSimilar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.\n\n\t```lua\n\t\tgetTheValue()\n\t\t:tap(print)\n\t\t:andThen(function(theValue)\n\t\t\tprint(\"Got\", theValue, \"even though print returns nil!\")\n\t\tend)\n\t```\n\n\tIf you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.\n\n\t@param tapHandler (...: any) -> ...any\n\t@return Promise<...any>\n]=]\nfunction Promise.prototype:tap(tapHandler)\n\tassert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, \"Promise:tap\"))\n\treturn self:_andThen(debug.traceback(nil, 2), function(...)\n\t\tlocal callbackReturn = tapHandler(...)\n\n\t\tif Promise.is(callbackReturn) then\n\t\t\tlocal length, values = pack(...)\n\t\t\treturn callbackReturn:andThen(function()\n\t\t\t\treturn unpack(values, 1, length)\n\t\t\tend)\n\t\tend\n\n\t\treturn ...\n\tend)\nend\n\n--[=[\n\tAttaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.\n\n\t```lua\n\t\tpromise:andThenCall(someFunction, \"some\", \"arguments\")\n\t```\n\n\tThis is sugar for\n\n\t```lua\n\t\tpromise:andThen(function()\n\t\treturn someFunction(\"some\", \"arguments\")\n\t\tend)\n\t```\n\n\t@param callback (...: any) -> any\n\t@param ...? any -- Additional arguments which will be passed to `callback`\n\t@return Promise\n]=]\nfunction Promise.prototype:andThenCall(callback, ...)\n\tassert(isCallable(callback), string.format(ERROR_NON_FUNCTION, \"Promise:andThenCall\"))\n\tlocal length, values = pack(...)\n\treturn self:_andThen(debug.traceback(nil, 2), function()\n\t\treturn callback(unpack(values, 1, length))\n\tend)\nend\n\n--[=[\n\tAttaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.\n\n\t```lua\n\t\tpromise:andThenReturn(\"some\", \"values\")\n\t```\n\n\tThis is sugar for\n\n\t```lua\n\t\tpromise:andThen(function()\n\t\t\treturn \"some\", \"values\"\n\t\tend)\n\t```\n\n\t:::caution\n\tPromises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].\n\t:::\n\n\t@param ... any -- Values to return from the function\n\t@return Promise\n]=]\nfunction Promise.prototype:andThenReturn(...)\n\tlocal length, values = pack(...)\n\treturn self:_andThen(debug.traceback(nil, 2), function()\n\t\treturn unpack(values, 1, length)\n\tend)\nend\n\n--[=[\n\tCancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.\n\n\tCancellations will propagate upwards and downwards through chained promises.\n\n\tPromises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.\n\n\t```lua\n\t\tpromise:cancel()\n\t```\n]=]\nfunction Promise.prototype:cancel()\n\tif self._status ~= Promise.Status.Started then\n\t\treturn\n\tend\n\n\tself._status = Promise.Status.Cancelled\n\n\tif self._cancellationHook then\n\t\tself._cancellationHook()\n\tend\n\n\tif self._parent then\n\t\tself._parent:_consumerCancelled(self)\n\tend\n\n\tfor child in pairs(self._consumers) do\n\t\tchild:cancel()\n\tend\n\n\tself:_finalize()\nend\n\n--[[\n\tUsed to decrease the number of consumers by 1, and if there are no more,\n\tcancel this promise.\n]]\nfunction Promise.prototype:_consumerCancelled(consumer)\n\tif self._status ~= Promise.Status.Started then\n\t\treturn\n\tend\n\n\tself._consumers[consumer] = nil\n\n\tif next(self._consumers) == nil then\n\t\tself:cancel()\n\tend\nend\n\n--[[\n\tUsed to set a handler for when the promise resolves, rejects, or is\n\tcancelled. Returns a new promise chained from this promise.\n]]\nfunction Promise.prototype:_finally(traceback, finallyHandler, onlyOk)\n\tif not onlyOk then\n\t\tself._unhandledRejection = false\n\tend\n\n\t-- Return a promise chained off of this promise\n\treturn Promise._new(traceback, function(resolve, reject)\n\t\tlocal finallyCallback = resolve\n\t\tif finallyHandler then\n\t\t\tfinallyCallback = createAdvancer(traceback, finallyHandler, resolve, reject)\n\t\tend\n\n\t\tif onlyOk then\n\t\t\tlocal callback = finallyCallback\n\t\t\tfinallyCallback = function(...)\n\t\t\t\tif self._status == Promise.Status.Rejected then\n\t\t\t\t\treturn resolve(self)\n\t\t\t\tend\n\n\t\t\t\treturn callback(...)\n\t\t\tend\n\t\tend\n\n\t\tif self._status == Promise.Status.Started then\n\t\t\t-- The promise is not settled, so queue this.\n\t\t\ttable.insert(self._queuedFinally, finallyCallback)\n\t\telse\n\t\t\t-- The promise already settled or was cancelled, run the callback now.\n\t\t\tfinallyCallback(self._status)\n\t\tend\n\tend, self)\nend\n\n--[=[\n\tSet a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, *or* cancelled.\n\n\tReturns a new promise chained from this promise.\n\n\t:::caution\n\tIf the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `finally` or `done` will run in the case of cancellation.\n\t:::\n\n\t```lua\n\tlocal thing = createSomething()\n\n\tdoSomethingWith(thing)\n\t\t:andThen(function()\n\t\t\tprint(\"It worked!\")\n\t\t\t-- do something..\n\t\tend)\n\t\t:catch(function()\n\t\t\twarn(\"Oh no it failed!\")\n\t\tend)\n\t\t:finally(function()\n\t\t\t-- either way, destroy thing\n\n\t\t\tthing:Destroy()\n\t\tend)\n\n\t```\n\n\t@param finallyHandler (status: Status) -> ...any\n\t@return Promise<...any>\n]=]\nfunction Promise.prototype:finally(finallyHandler)\n\tassert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, \"Promise:finally\"))\n\treturn self:_finally(debug.traceback(nil, 2), finallyHandler)\nend\n\n--[=[\n\tSame as `andThenCall`, except for `finally`.\n\n\tAttaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.\n\n\t@param callback (...: any) -> any\n\t@param ...? any -- Additional arguments which will be passed to `callback`\n\t@return Promise\n]=]\nfunction Promise.prototype:finallyCall(callback, ...)\n\tassert(isCallable(callback), string.format(ERROR_NON_FUNCTION, \"Promise:finallyCall\"))\n\tlocal length, values = pack(...)\n\treturn self:_finally(debug.traceback(nil, 2), function()\n\t\treturn callback(unpack(values, 1, length))\n\tend)\nend\n\n--[=[\n\tAttaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.\n\n\t```lua\n\t\tpromise:finallyReturn(\"some\", \"values\")\n\t```\n\n\tThis is sugar for\n\n\t```lua\n\t\tpromise:finally(function()\n\t\t\treturn \"some\", \"values\"\n\t\tend)\n\t```\n\n\t@param ... any -- Values to return from the function\n\t@return Promise\n]=]\nfunction Promise.prototype:finallyReturn(...)\n\tlocal length, values = pack(...)\n\treturn self:_finally(debug.traceback(nil, 2), function()\n\t\treturn unpack(values, 1, length)\n\tend)\nend\n\n--[=[\n\tSet a handler that will be called only if the Promise resolves or is cancelled. This method is similar to `finally`, except it doesn't catch rejections.\n\n\t:::caution\n\t`done` should be reserved specifically when you want to perform some operation after the Promise is finished (like `finally`), but you don't want to consume rejections (like in <a href=\"/roblox-lua-promise/lib/Examples.html#cancellable-animation-sequence\">this example</a>). You should use `andThen` instead if you only care about the Resolved case.\n\t:::\n\n\t:::warning\n\tLike `finally`, if the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `done` and `finally` will run in the case of cancellation.\n\t:::\n\n\tReturns a new promise chained from this promise.\n\n\t@param doneHandler (status: Status) -> ...any\n\t@return Promise<...any>\n]=]\nfunction Promise.prototype:done(doneHandler)\n\tassert(doneHandler == nil or isCallable(doneHandler), string.format(ERROR_NON_FUNCTION, \"Promise:done\"))\n\treturn self:_finally(debug.traceback(nil, 2), doneHandler, true)\nend\n\n--[=[\n\tSame as `andThenCall`, except for `done`.\n\n\tAttaches a `done` handler to this Promise that calls the given callback with the predefined arguments.\n\n\t@param callback (...: any) -> any\n\t@param ...? any -- Additional arguments which will be passed to `callback`\n\t@return Promise\n]=]\nfunction Promise.prototype:doneCall(callback, ...)\n\tassert(isCallable(callback), string.format(ERROR_NON_FUNCTION, \"Promise:doneCall\"))\n\tlocal length, values = pack(...)\n\treturn self:_finally(debug.traceback(nil, 2), function()\n\t\treturn callback(unpack(values, 1, length))\n\tend, true)\nend\n\n--[=[\n\tAttaches a `done` handler to this Promise that discards the resolved value and returns the given value from it.\n\n\t```lua\n\t\tpromise:doneReturn(\"some\", \"values\")\n\t```\n\n\tThis is sugar for\n\n\t```lua\n\t\tpromise:done(function()\n\t\t\treturn \"some\", \"values\"\n\t\tend)\n\t```\n\n\t@param ... any -- Values to return from the function\n\t@return Promise\n]=]\nfunction Promise.prototype:doneReturn(...)\n\tlocal length, values = pack(...)\n\treturn self:_finally(debug.traceback(nil, 2), function()\n\t\treturn unpack(values, 1, length)\n\tend, true)\nend\n\n--[=[\n\tYields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.\n\n\t@yields\n\t@return Status -- The Status representing the fate of the Promise\n\t@return ...any -- The values the Promise resolved or rejected with.\n]=]\nfunction Promise.prototype:awaitStatus()\n\tself._unhandledRejection = false\n\n\tif self._status == Promise.Status.Started then\n\t\tlocal bindable = Instance.new(\"BindableEvent\")\n\n\t\tself:finally(function()\n\t\t\tbindable:Fire()\n\t\tend)\n\n\t\tbindable.Event:Wait()\n\t\tbindable:Destroy()\n\tend\n\n\tif self._status == Promise.Status.Resolved then\n\t\treturn self._status, unpack(self._values, 1, self._valuesLength)\n\telseif self._status == Promise.Status.Rejected then\n\t\treturn self._status, unpack(self._values, 1, self._valuesLength)\n\tend\n\n\treturn self._status\nend\n\nlocal function awaitHelper(status, ...)\n\treturn status == Promise.Status.Resolved, ...\nend\n\n--[=[\n\tYields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.\n\n\t:::caution\n\tIf the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.\n\t:::\n\n\t```lua\n\t\tlocal worked, value = getTheValue():await()\n\n\tif worked then\n\t\tprint(\"got\", value)\n\telse\n\t\twarn(\"it failed\")\n\tend\n\t```\n\n\t@yields\n\t@return boolean -- `true` if the Promise successfully resolved\n\t@return ...any -- The values the Promise resolved or rejected with.\n]=]\nfunction Promise.prototype:await()\n\treturn awaitHelper(self:awaitStatus())\nend\n\nlocal function expectHelper(status, ...)\n\tif status ~= Promise.Status.Resolved then\n\t\terror((...) == nil and \"Expected Promise rejected with no value.\" or (...), 3)\n\tend\n\n\treturn ...\nend\n\n--[=[\n\tYields the current thread until the given Promise completes. Returns the values that the promise resolved with.\n\n\t```lua\n\tlocal worked = pcall(function()\n\t\tprint(\"got\", getTheValue():expect())\n\tend)\n\n\tif not worked then\n\t\twarn(\"it failed\")\n\tend\n\t```\n\n\tThis is essentially sugar for:\n\n\t```lua\n\tselect(2, assert(promise:await()))\n\t```\n\n\t**Errors** if the Promise rejects or gets cancelled.\n\n\t@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.\n\t@yields\n\t@return ...any -- The values the Promise resolved with.\n]=]\nfunction Promise.prototype:expect()\n\treturn expectHelper(self:awaitStatus())\nend\n\n-- Backwards compatibility\nPromise.prototype.awaitValue = Promise.prototype.expect\n\n--[[\n\tIntended for use in tests.\n\n\tSimilar to await(), but instead of yielding if the promise is unresolved,\n\t_unwrap will throw. This indicates an assumption that a promise has\n\tresolved.\n]]\nfunction Promise.prototype:_unwrap()\n\tif self._status == Promise.Status.Started then\n\t\terror(\"Promise has not resolved or rejected.\", 2)\n\tend\n\n\tlocal success = self._status == Promise.Status.Resolved\n\n\treturn success, unpack(self._values, 1, self._valuesLength)\nend\n\nfunction Promise.prototype:_resolve(...)\n\tif self._status ~= Promise.Status.Started then\n\t\tif Promise.is((...)) then\n\t\t\t(...):_consumerCancelled(self)\n\t\tend\n\t\treturn\n\tend\n\n\t-- If the resolved value was a Promise, we chain onto it!\n\tif Promise.is((...)) then\n\t\t-- Without this warning, arguments sometimes mysteriously disappear\n\t\tif select(\"#\", ...) > 1 then\n\t\t\tlocal message = string.format(\n\t\t\t\t\"When returning a Promise from andThen, extra arguments are \" .. \"discarded! See:\\n\\n%s\",\n\t\t\t\tself._source\n\t\t\t)\n\t\t\twarn(message)\n\t\tend\n\n\t\tlocal chainedPromise = ...\n\n\t\tlocal promise = chainedPromise:andThen(function(...)\n\t\t\tself:_resolve(...)\n\t\tend, function(...)\n\t\t\tlocal maybeRuntimeError = chainedPromise._values[1]\n\n\t\t\t-- Backwards compatibility < v2\n\t\t\tif chainedPromise._error then\n\t\t\t\tmaybeRuntimeError = Error.new({\n\t\t\t\t\terror = chainedPromise._error,\n\t\t\t\t\tkind = Error.Kind.ExecutionError,\n\t\t\t\t\tcontext = \"[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]\",\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tif Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then\n\t\t\t\treturn self:_reject(maybeRuntimeError:extend({\n\t\t\t\t\terror = \"This Promise was chained to a Promise that errored.\",\n\t\t\t\t\ttrace = \"\",\n\t\t\t\t\tcontext = string.format(\n\t\t\t\t\t\t\"The Promise at:\\n\\n%s\\n...Rejected because it was chained to the following Promise, which encountered an error:\\n\",\n\t\t\t\t\t\tself._source\n\t\t\t\t\t),\n\t\t\t\t}))\n\t\t\tend\n\n\t\t\tself:_reject(...)\n\t\tend)\n\n\t\tif promise._status == Promise.Status.Cancelled then\n\t\t\tself:cancel()\n\t\telseif promise._status == Promise.Status.Started then\n\t\t\t-- Adopt ourselves into promise for cancellation propagation.\n\t\t\tself._parent = promise\n\t\t\tpromise._consumers[self] = true\n\t\tend\n\n\t\treturn\n\tend\n\n\tself._status = Promise.Status.Resolved\n\tself._valuesLength, self._values = pack(...)\n\n\t-- We assume that these callbacks will not throw errors.\n\tfor _, callback in ipairs(self._queuedResolve) do\n\t\tcoroutine.wrap(callback)(...)\n\tend\n\n\tself:_finalize()\nend\n\nfunction Promise.prototype:_reject(...)\n\tif self._status ~= Promise.Status.Started then\n\t\treturn\n\tend\n\n\tself._status = Promise.Status.Rejected\n\tself._valuesLength, self._values = pack(...)\n\n\t-- If there are any rejection handlers, call those!\n\tif not isEmpty(self._queuedReject) then\n\t\t-- We assume that these callbacks will not throw errors.\n\t\tfor _, callback in ipairs(self._queuedReject) do\n\t\t\tcoroutine.wrap(callback)(...)\n\t\tend\n\telse\n\t\t-- At this point, no one was able to observe the error.\n\t\t-- An error handler might still be attached if the error occurred\n\t\t-- synchronously. We'll wait one tick, and if there are still no\n\t\t-- observers, then we should put a message in the console.\n\n\t\tlocal err = tostring((...))\n\n\t\tcoroutine.wrap(function()\n\t\t\tPromise._timeEvent:Wait()\n\n\t\t\t-- Someone observed the error, hooray!\n\t\t\tif not self._unhandledRejection then\n\t\t\t\treturn\n\t\t\tend\n\n\t\t\t-- Build a reasonable message\n\t\t\tlocal message = string.format(\"Unhandled Promise rejection:\\n\\n%s\\n\\n%s\", err, self._source)\n\n\t\t\tfor _, callback in ipairs(Promise._unhandledRejectionCallbacks) do\n\t\t\t\ttask.spawn(callback, self, unpack(self._values, 1, self._valuesLength))\n\t\t\tend\n\n\t\t\tif Promise.TEST then\n\t\t\t\t-- Don't spam output when we're running tests.\n\t\t\t\treturn\n\t\t\tend\n\n\t\t\twarn(message)\n\t\tend)()\n\tend\n\n\tself:_finalize()\nend\n\n--[[\n\tCalls any :finally handlers. We need this to be a separate method and\n\tqueue because we must call all of the finally callbacks upon a success,\n\tfailure, *and* cancellation.\n]]\nfunction Promise.prototype:_finalize()\n\tfor _, callback in ipairs(self._queuedFinally) do\n\t\t-- Purposefully not passing values to callbacks here, as it could be the\n\t\t-- resolved values, or rejected errors. If the developer needs the values,\n\t\t-- they should use :andThen or :catch explicitly.\n\t\tcoroutine.wrap(callback)(self._status)\n\tend\n\n\tself._queuedFinally = nil\n\tself._queuedReject = nil\n\tself._queuedResolve = nil\n\n\t-- Clear references to other Promises to allow gc\n\tif not Promise.TEST then\n\t\tself._parent = nil\n\t\tself._consumers = nil\n\tend\nend\n\n--[=[\n\tChains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.\n\n\t```lua\n\tdoSomething()\n\t\t:now()\n\t\t:andThen(function(value)\n\t\t\tprint(\"Got\", value, \"synchronously.\")\n\t\tend)\n\t```\n\n\tIf this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].\n\n\t@param rejectionValue? any -- The value to reject with if the Promise isn't resolved\n\t@return Promise\n]=]\nfunction Promise.prototype:now(rejectionValue)\n\tlocal traceback = debug.traceback(nil, 2)\n\tif self._status == Promise.Status.Resolved then\n\t\treturn self:_andThen(traceback, function(...)\n\t\t\treturn ...\n\t\tend)\n\telse\n\t\treturn Promise.reject(rejectionValue == nil and Error.new({\n\t\t\tkind = Error.Kind.NotResolvedInTime,\n\t\t\terror = \"This Promise was not resolved in time for :now()\",\n\t\t\tcontext = \":now() was called at:\\n\\n\" .. traceback,\n\t\t}) or rejectionValue)\n\tend\nend\n\n--[=[\n\tRepeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.\n\n\tIf the amount of retries is exceeded, the function will return the latest rejected Promise.\n\n\t```lua\n\tlocal function canFail(a, b, c)\n\t\treturn Promise.new(function(resolve, reject)\n\t\t\t-- do something that can fail\n\n\t\t\tlocal failed, thing = doSomethingThatCanFail(a, b, c)\n\n\t\t\tif failed then\n\t\t\t\treject(\"it failed\")\n\t\t\telse\n\t\t\t\tresolve(thing)\n\t\t\tend\n\t\tend)\n\tend\n\n\tlocal MAX_RETRIES = 10\n\tlocal value = Promise.retry(canFail, MAX_RETRIES, \"foo\", \"bar\", \"baz\") -- args to send to canFail\n\t```\n\n\t@since 3.0.0\n\t@param callback (...: P) -> Promise<T>\n\t@param times number\n\t@param ...? P\n]=]\nfunction Promise.retry(callback, times, ...)\n\tassert(isCallable(callback), \"Parameter #1 to Promise.retry must be a function\")\n\tassert(type(times) == \"number\", \"Parameter #2 to Promise.retry must be a number\")\n\n\tlocal args, length = { ... }, select(\"#\", ...)\n\n\treturn Promise.resolve(callback(...)):catch(function(...)\n\t\tif times > 0 then\n\t\t\treturn Promise.retry(callback, times - 1, unpack(args, 1, length))\n\t\telse\n\t\t\treturn Promise.reject(...)\n\t\tend\n\tend)\nend\n\n--[=[\n\tRepeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each\n\tretry, until the returned Promise resolves.\n\n\tIf the amount of retries is exceeded, the function will return the latest rejected Promise.\n\n\t@since v3.2.0\n\t@param callback (...: P) -> Promise<T>\n\t@param times number\n\t@param seconds number\n\t@param ...? P\n]=]\nfunction Promise.retryWithDelay(callback, times, seconds, ...)\n\tassert(isCallable(callback), \"Parameter #1 to Promise.retry must be a function\")\n\tassert(type(times) == \"number\", \"Parameter #2 (times) to Promise.retry must be a number\")\n\tassert(type(seconds) == \"number\", \"Parameter #3 (seconds) to Promise.retry must be a number\")\n\n\tlocal args, length = { ... }, select(\"#\", ...)\n\n\treturn Promise.resolve(callback(...)):catch(function(...)\n\t\tif times > 0 then\n\t\t\tPromise.delay(seconds):await()\n\n\t\t\treturn Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))\n\t\telse\n\t\t\treturn Promise.reject(...)\n\t\tend\n\tend)\nend\n\n--[=[\n\tConverts an event into a Promise which resolves the next time the event fires.\n\n\tThe optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.\n\n\tThe Promise will resolve with the event arguments.\n\n\t:::tip\n\tThis function will work given any object with a `Connect` method. This includes all Roblox events.\n\t:::\n\n\t```lua\n\t-- Creates a Promise which only resolves when `somePart` is touched\n\t-- by a part named `\"Something specific\"`.\n\treturn Promise.fromEvent(somePart.Touched, function(part)\n\t\treturn part.Name == \"Something specific\"\n\tend)\n\t```\n\n\t@since 3.0.0\n\t@param event Event -- Any object with a `Connect` method. This includes all Roblox events.\n\t@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.\n\t@return Promise<P>\n]=]\nfunction Promise.fromEvent(event, predicate)\n\tpredicate = predicate or function()\n\t\treturn true\n\tend\n\n\treturn Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)\n\t\tlocal connection\n\t\tlocal shouldDisconnect = false\n\n\t\tlocal function disconnect()\n\t\t\tconnection:Disconnect()\n\t\t\tconnection = nil\n\t\tend\n\n\t\t-- We use shouldDisconnect because if the callback given to Connect is called before\n\t\t-- Connect returns, connection will still be nil. This happens with events that queue up\n\t\t-- events when there's nothing connected, such as RemoteEvents\n\n\t\tconnection = event:Connect(function(...)\n\t\t\tlocal callbackValue = predicate(...)\n\n\t\t\tif callbackValue == true then\n\t\t\t\tresolve(...)\n\n\t\t\t\tif connection then\n\t\t\t\t\tdisconnect()\n\t\t\t\telse\n\t\t\t\t\tshouldDisconnect = true\n\t\t\t\tend\n\t\t\telseif type(callbackValue) ~= \"boolean\" then\n\t\t\t\terror(\"Promise.fromEvent predicate should always return a boolean\")\n\t\t\tend\n\t\tend)\n\n\t\tif shouldDisconnect and connection then\n\t\t\treturn disconnect()\n\t\tend\n\n\t\tonCancel(disconnect)\n\tend)\nend\n\n--[=[\n\tRegisters a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise\n\tis rejected, and the rejection is not observed with `:catch`.\n\n\tThe callback is called with the actual promise that rejected, followed by the rejection values.\n\n\t@since v3.2.0\n\t@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.\n\t@return () -> () -- Function that unregisters the `callback` when called\n]=]\nfunction Promise.onUnhandledRejection(callback)\n\ttable.insert(Promise._unhandledRejectionCallbacks, callback)\n\n\treturn function()\n\t\tlocal index = table.find(Promise._unhandledRejectionCallbacks, callback)\n\n\t\tif index then\n\t\t\ttable.remove(Promise._unhandledRejectionCallbacks, index)\n\t\tend\n\tend\nend\n\nreturn Promise\n"
          }
        }, {
          Children = {},
          Properties = {
            ClassName = "ModuleScript",
            Name = "RuntimeLib",
            Source = 'local Promise = require(script.Parent.Promise)\n\nlocal RunService = game:GetService("RunService")\n\nlocal OUTPUT_PREFIX = "roblox-ts: "\nlocal NODE_MODULES = "node_modules"\nlocal DEFAULT_SCOPE = "@rbxts"\n\nlocal TS = {}\n\nTS.Promise = Promise\n\nlocal function isPlugin(context)\n\treturn RunService:IsStudio() and context:FindFirstAncestorWhichIsA("Plugin") ~= nil\nend\n\nfunction TS.getModule(context, scope, moduleName)\n\t-- legacy call signature\n\tif moduleName == nil then\n\t\tmoduleName = scope\n\t\tscope = DEFAULT_SCOPE\n\tend\n\n\t-- ensure modules have fully replicated\n\tif RunService:IsRunning() and RunService:IsClient() and not isPlugin(context) and not game:IsLoaded() then\n\t\tgame.Loaded:Wait()\n\tend\n\n\tlocal object = context\n\trepeat\n\t\tlocal nodeModulesFolder = object:FindFirstChild(NODE_MODULES)\n\t\tif nodeModulesFolder then\n\t\t\tlocal scopeFolder = nodeModulesFolder:FindFirstChild(scope)\n\t\t\tif scopeFolder then\n\t\t\t\tlocal module = scopeFolder:FindFirstChild(moduleName)\n\t\t\t\tif module then\n\t\t\t\t\treturn module\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tobject = object.Parent\n\tuntil object == nil\n\n\terror(OUTPUT_PREFIX .. "Could not find module: " .. moduleName, 2)\nend\n\n-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library\nlocal currentlyLoading = {}\nlocal registeredLibraries = {}\n\nfunction TS.import(context, module, ...)\n\tfor i = 1, select("#", ...) do\n\t\tmodule = module:WaitForChild((select(i, ...)))\n\tend\n\n\tif module.ClassName ~= "ModuleScript" then\n\t\terror(OUTPUT_PREFIX .. "Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)\n\tend\n\n\tcurrentlyLoading[context] = module\n\n\t-- Check to see if a case like this occurs:\n\t-- module -> Module1 -> Module2 -> module\n\n\t-- WHERE currentlyLoading[module] is Module1\n\t-- and currentlyLoading[Module1] is Module2\n\t-- and currentlyLoading[Module2] is module\n\n\tlocal currentModule = module\n\tlocal depth = 0\n\n\twhile currentModule do\n\t\tdepth = depth + 1\n\t\tcurrentModule = currentlyLoading[currentModule]\n\n\t\tif currentModule == module then\n\t\t\tlocal str = currentModule.Name -- Get the string traceback\n\n\t\t\tfor _ = 1, depth do\n\t\t\t\tcurrentModule = currentlyLoading[currentModule]\n\t\t\t\tstr = str .. "  ⇒ " .. currentModule.Name\n\t\t\tend\n\n\t\t\terror(OUTPUT_PREFIX .. "Failed to import! Detected a circular dependency chain: " .. str, 2)\n\t\tend\n\tend\n\n\tif not registeredLibraries[module] then\n\t\tif _G[module] then\n\t\t\terror(\n\t\t\t\tOUTPUT_PREFIX\n\t\t\t\t.. "Invalid module access! Do you have multiple TS runtimes trying to import this? "\n\t\t\t\t.. module:GetFullName(),\n\t\t\t\t2\n\t\t\t)\n\t\tend\n\n\t\t_G[module] = TS\n\t\tregisteredLibraries[module] = true -- register as already loaded for subsequent calls\n\tend\n\n\tlocal data = require(module)\n\n\tif currentlyLoading[context] == module then -- Thread-safe cleanup!\n\t\tcurrentlyLoading[context] = nil\n\tend\n\n\treturn data\nend\n\nfunction TS.instanceof(obj, class)\n\t-- custom Class.instanceof() check\n\tif type(class) == "table" and type(class.instanceof) == "function" then\n\t\treturn class.instanceof(obj)\n\tend\n\n\t-- metatable check\n\tif type(obj) == "table" then\n\t\tobj = getmetatable(obj)\n\t\twhile obj ~= nil do\n\t\t\tif obj == class then\n\t\t\t\treturn true\n\t\t\tend\n\t\t\tlocal mt = getmetatable(obj)\n\t\t\tif mt then\n\t\t\t\tobj = mt.__index\n\t\t\telse\n\t\t\t\tobj = nil\n\t\t\tend\n\t\tend\n\tend\n\n\treturn false\nend\n\nfunction TS.async(callback)\n\treturn function(...)\n\t\tlocal n = select("#", ...)\n\t\tlocal args = { ... }\n\t\treturn Promise.new(function(resolve, reject)\n\t\t\tcoroutine.wrap(function()\n\t\t\t\tlocal ok, result = pcall(callback, unpack(args, 1, n))\n\t\t\t\tif ok then\n\t\t\t\t\tresolve(result)\n\t\t\t\telse\n\t\t\t\t\treject(result)\n\t\t\t\tend\n\t\t\tend)()\n\t\tend)\n\tend\nend\n\nfunction TS.await(promise)\n\tif not Promise.is(promise) then\n\t\treturn promise\n\tend\n\n\tlocal status, value = promise:awaitStatus()\n\tif status == Promise.Status.Resolved then\n\t\treturn value\n\telseif status == Promise.Status.Rejected then\n\t\terror(value, 2)\n\telse\n\t\terror("The awaited Promise was cancelled", 2)\n\tend\nend\n\nlocal SIGN = 2 ^ 31\nlocal COMPLEMENT = 2 ^ 32\nlocal function bit_sign(num)\n\t-- Restores the sign after an unsigned conversion according to 2s complement.\n\tif bit32.btest(num, SIGN) then\n\t\treturn num - COMPLEMENT\n\telse\n\t\treturn num\n\tend\nend\n\nfunction TS.bit_lrsh(a, b)\n\treturn bit_sign(bit32.arshift(a, b))\nend\n\nTS.TRY_RETURN = 1\nTS.TRY_BREAK = 2\nTS.TRY_CONTINUE = 3\n\nfunction TS.try(func, catch, finally)\n\tlocal err, traceback\n\tlocal success, exitType, returns = xpcall(\n\t\tfunc,\n\t\tfunction(errInner)\n\t\t\terr = errInner\n\t\t\ttraceback = debug.traceback()\n\t\tend\n\t)\n\tif not success and catch then\n\t\tlocal newExitType, newReturns = catch(err, traceback)\n\t\tif newExitType then\n\t\t\texitType, returns = newExitType, newReturns\n\t\tend\n\tend\n\tif finally then\n\t\tlocal newExitType, newReturns = finally()\n\t\tif newExitType then\n\t\t\texitType, returns = newExitType, newReturns\n\t\tend\n\tend\n\treturn exitType, returns\nend\n\nfunction TS.generator(callback)\n\tlocal co = coroutine.create(callback)\n\treturn {\n\t\tnext = function(...)\n\t\t\tif coroutine.status(co) == "dead" then\n\t\t\t\treturn { done = true }\n\t\t\telse\n\t\t\t\tlocal success, value = coroutine.resume(co, ...)\n\t\t\t\tif success == false then\n\t\t\t\t\terror(value, 2)\n\t\t\t\tend\n\t\t\t\treturn {\n\t\t\t\t\tvalue = value,\n\t\t\t\t\tdone = coroutine.status(co) == "dead",\n\t\t\t\t}\n\t\t\tend\n\t\tend,\n\t}\nend\n\nreturn TS\n'
          }
        }, {
          Children = { {
              Children = { {
                  Children = { {
                      Children = {},
                      Properties = {
                        ClassName = "Folder",
                        Name = "types"
                      }
                    } },
                  Properties = {
                    ClassName = "Folder",
                    Name = "compiler-types"
                  }
                }, {
                  Children = { {
                      Children = { {
                          Children = {},
                          Properties = {
                            ClassName = "Folder",
                            Name = "generated"
                          }
                        } },
                      Properties = {
                        ClassName = "Folder",
                        Name = "include"
                      }
                    } },
                  Properties = {
                    ClassName = "Folder",
                    Name = "types"
                  }
                }, {
                  Children = { {
                      Children = { {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "Binding",
                            Source = 'local createSignal = require(script.Parent.createSignal)\nlocal Symbol = require(script.Parent.Symbol)\nlocal Type = require(script.Parent.Type)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal BindingImpl = Symbol.named("BindingImpl")\n\nlocal BindingInternalApi = {}\n\nlocal bindingPrototype = {}\n\nfunction bindingPrototype:getValue()\n\treturn BindingInternalApi.getValue(self)\nend\n\nfunction bindingPrototype:map(predicate)\n\treturn BindingInternalApi.map(self, predicate)\nend\n\nlocal BindingPublicMeta = {\n\t__index = bindingPrototype,\n\t__tostring = function(self)\n\t\treturn string.format("RoactBinding(%s)", tostring(self:getValue()))\n\tend,\n}\n\nfunction BindingInternalApi.update(binding, newValue)\n\treturn binding[BindingImpl].update(newValue)\nend\n\nfunction BindingInternalApi.subscribe(binding, callback)\n\treturn binding[BindingImpl].subscribe(callback)\nend\n\nfunction BindingInternalApi.getValue(binding)\n\treturn binding[BindingImpl].getValue()\nend\n\nfunction BindingInternalApi.create(initialValue)\n\tlocal impl = {\n\t\tvalue = initialValue,\n\t\tchangeSignal = createSignal(),\n\t}\n\n\tfunction impl.subscribe(callback)\n\t\treturn impl.changeSignal:subscribe(callback)\n\tend\n\n\tfunction impl.update(newValue)\n\t\timpl.value = newValue\n\t\timpl.changeSignal:fire(newValue)\n\tend\n\n\tfunction impl.getValue()\n\t\treturn impl.value\n\tend\n\n\treturn setmetatable({\n\t\t[Type] = Type.Binding,\n\t\t[BindingImpl] = impl,\n\t}, BindingPublicMeta), impl.update\nend\n\nfunction BindingInternalApi.map(upstreamBinding, predicate)\n\tif config.typeChecks then\n\t\tassert(Type.of(upstreamBinding) == Type.Binding, "Expected arg #1 to be a binding")\n\t\tassert(typeof(predicate) == "function", "Expected arg #1 to be a function")\n\tend\n\n\tlocal impl = {}\n\n\tfunction impl.subscribe(callback)\n\t\treturn BindingInternalApi.subscribe(upstreamBinding, function(newValue)\n\t\t\tcallback(predicate(newValue))\n\t\tend)\n\tend\n\n\tfunction impl.update(_newValue)\n\t\terror("Bindings created by Binding:map(fn) cannot be updated directly", 2)\n\tend\n\n\tfunction impl.getValue()\n\t\treturn predicate(upstreamBinding:getValue())\n\tend\n\n\treturn setmetatable({\n\t\t[Type] = Type.Binding,\n\t\t[BindingImpl] = impl,\n\t}, BindingPublicMeta)\nend\n\nfunction BindingInternalApi.join(upstreamBindings)\n\tif config.typeChecks then\n\t\tassert(typeof(upstreamBindings) == "table", "Expected arg #1 to be of type table")\n\n\t\tfor key, value in pairs(upstreamBindings) do\n\t\t\tif Type.of(value) ~= Type.Binding then\n\t\t\t\tlocal message = ("Expected arg #1 to contain only bindings, but key %q had a non-binding value"):format(\n\t\t\t\t\ttostring(key)\n\t\t\t\t)\n\t\t\t\terror(message, 2)\n\t\t\tend\n\t\tend\n\tend\n\n\tlocal impl = {}\n\n\tlocal function getValue()\n\t\tlocal value = {}\n\n\t\tfor key, upstream in pairs(upstreamBindings) do\n\t\t\tvalue[key] = upstream:getValue()\n\t\tend\n\n\t\treturn value\n\tend\n\n\tfunction impl.subscribe(callback)\n\t\tlocal disconnects = {}\n\n\t\tfor key, upstream in pairs(upstreamBindings) do\n\t\t\tdisconnects[key] = BindingInternalApi.subscribe(upstream, function(_newValue)\n\t\t\t\tcallback(getValue())\n\t\t\tend)\n\t\tend\n\n\t\treturn function()\n\t\t\tif disconnects == nil then\n\t\t\t\treturn\n\t\t\tend\n\n\t\t\tfor _, disconnect in pairs(disconnects) do\n\t\t\t\tdisconnect()\n\t\t\tend\n\n\t\t\tdisconnects = nil :: any\n\t\tend\n\tend\n\n\tfunction impl.update(_newValue)\n\t\terror("Bindings created by joinBindings(...) cannot be updated directly", 2)\n\tend\n\n\tfunction impl.getValue()\n\t\treturn getValue()\n\tend\n\n\treturn setmetatable({\n\t\t[Type] = Type.Binding,\n\t\t[BindingImpl] = impl,\n\t}, BindingPublicMeta)\nend\n\nreturn BindingInternalApi\n'
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "Component",
                            Source = "local assign = require(script.Parent.assign)\nlocal ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)\nlocal Type = require(script.Parent.Type)\nlocal Symbol = require(script.Parent.Symbol)\nlocal invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)\nlocal internalAssert = require(script.Parent.internalAssert)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\n--[[\n\tCalling setState during certain lifecycle allowed methods has the potential\n\tto create an infinitely updating component. Rather than time out, we exit\n\twith an error if an unreasonable number of self-triggering updates occur\n]]\nlocal MAX_PENDING_UPDATES = 100\n\nlocal InternalData = Symbol.named(\"InternalData\")\n\nlocal componentMissingRenderMessage = [[\nThe component %q is missing the `render` method.\n`render` must be defined when creating a Roact component!]]\n\nlocal tooManyUpdatesMessage = [[\nThe component %q has reached the setState update recursion limit.\nWhen using `setState` in `didUpdate`, make sure that it won't repeat infinitely!]]\n\nlocal componentClassMetatable = {}\n\nfunction componentClassMetatable:__tostring()\n\treturn self.__componentName\nend\n\nlocal Component = {}\nsetmetatable(Component, componentClassMetatable)\n\nComponent[Type] = Type.StatefulComponentClass\nComponent.__index = Component\nComponent.__componentName = \"Component\"\n\n--[[\n\tA method called by consumers of Roact to create a new component class.\n\tComponents can not be extended beyond this point, with the exception of\n\tPureComponent.\n]]\nfunction Component:extend(name)\n\tif config.typeChecks then\n\t\tassert(Type.of(self) == Type.StatefulComponentClass, \"Invalid `self` argument to `extend`.\")\n\t\tassert(typeof(name) == \"string\", \"Component class name must be a string\")\n\tend\n\n\tlocal class = {}\n\n\tfor key, value in pairs(self) do\n\t\t-- Roact opts to make consumers use composition over inheritance, which\n\t\t-- lines up with React.\n\t\t-- https://reactjs.org/docs/composition-vs-inheritance.html\n\t\tif key ~= \"extend\" then\n\t\t\tclass[key] = value\n\t\tend\n\tend\n\n\tclass[Type] = Type.StatefulComponentClass\n\tclass.__index = class\n\tclass.__componentName = name\n\n\tsetmetatable(class, componentClassMetatable)\n\n\treturn class\nend\n\nfunction Component:__getDerivedState(incomingProps, incomingState)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__getDerivedState`\")\n\tend\n\n\tlocal internalData = self[InternalData]\n\tlocal componentClass = internalData.componentClass\n\n\tif componentClass.getDerivedStateFromProps ~= nil then\n\t\tlocal derivedState = componentClass.getDerivedStateFromProps(incomingProps, incomingState)\n\n\t\tif derivedState ~= nil then\n\t\t\tif config.typeChecks then\n\t\t\t\tassert(typeof(derivedState) == \"table\", \"getDerivedStateFromProps must return a table!\")\n\t\t\tend\n\n\t\t\treturn derivedState\n\t\tend\n\tend\n\n\treturn nil\nend\n\nfunction Component:setState(mapState)\n\tif config.typeChecks then\n\t\tassert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid `self` argument to `extend`.\")\n\tend\n\n\tlocal internalData = self[InternalData]\n\tlocal lifecyclePhase = internalData.lifecyclePhase\n\n\t--[[\n\t\tWhen preparing to update, render, or unmount, it is not safe\n\t\tto call `setState` as it will interfere with in-flight updates. It's\n\t\talso disallowed during unmounting\n\t]]\n\tif\n\t\tlifecyclePhase == ComponentLifecyclePhase.ShouldUpdate\n\t\tor lifecyclePhase == ComponentLifecyclePhase.WillUpdate\n\t\tor lifecyclePhase == ComponentLifecyclePhase.Render\n\tthen\n\t\tlocal messageTemplate = invalidSetStateMessages[internalData.lifecyclePhase]\n\n\t\tlocal message = messageTemplate:format(tostring(internalData.componentClass))\n\t\terror(message, 2)\n\telseif lifecyclePhase == ComponentLifecyclePhase.WillUnmount then\n\t\t-- Should not print error message. See https://github.com/facebook/react/pull/22114\n\t\treturn\n\tend\n\n\tlocal pendingState = internalData.pendingState\n\n\tlocal partialState\n\tif typeof(mapState) == \"function\" then\n\t\tpartialState = mapState(pendingState or self.state, self.props)\n\n\t\t-- Abort the state update if the given state updater function returns nil\n\t\tif partialState == nil then\n\t\t\treturn\n\t\tend\n\telseif typeof(mapState) == \"table\" then\n\t\tpartialState = mapState\n\telse\n\t\terror(\"Invalid argument to setState, expected function or table\", 2)\n\tend\n\n\tlocal newState\n\tif pendingState ~= nil then\n\t\tnewState = assign(pendingState, partialState)\n\telse\n\t\tnewState = assign({}, self.state, partialState)\n\tend\n\n\tif lifecyclePhase == ComponentLifecyclePhase.Init then\n\t\t-- If `setState` is called in `init`, we can skip triggering an update!\n\t\tlocal derivedState = self:__getDerivedState(self.props, newState)\n\t\tself.state = assign(newState, derivedState)\n\telseif\n\t\tlifecyclePhase == ComponentLifecyclePhase.DidMount\n\t\tor lifecyclePhase == ComponentLifecyclePhase.DidUpdate\n\t\tor lifecyclePhase == ComponentLifecyclePhase.ReconcileChildren\n\tthen\n\t\t--[[\n\t\t\tDuring certain phases of the component lifecycle, it's acceptable to\n\t\t\tallow `setState` but defer the update until we're done with ones in flight.\n\t\t\tWe do this by collapsing it into any pending updates we have.\n\t\t]]\n\t\tlocal derivedState = self:__getDerivedState(self.props, newState)\n\t\tinternalData.pendingState = assign(newState, derivedState)\n\telseif lifecyclePhase == ComponentLifecyclePhase.Idle then\n\t\t-- Outside of our lifecycle, the state update is safe to make immediately\n\t\tself:__update(nil, newState)\n\telse\n\t\tlocal messageTemplate = invalidSetStateMessages.default\n\n\t\tlocal message = messageTemplate:format(tostring(internalData.componentClass))\n\n\t\terror(message, 2)\n\tend\nend\n\n--[[\n\tReturns the stack trace of where the element was created that this component\n\tinstance's properties are based on.\n\n\tIntended to be used primarily by diagnostic tools.\n]]\nfunction Component:getElementTraceback()\n\treturn self[InternalData].virtualNode.currentElement.source\nend\n\n--[[\n\tReturns a snapshot of this component given the current props and state. Must\n\tbe overridden by consumers of Roact and should be a pure function with\n\tregards to props and state.\n\n\tTODO (#199): Accept props and state as arguments.\n]]\nfunction Component:render()\n\tlocal internalData = self[InternalData]\n\n\tlocal message = componentMissingRenderMessage:format(tostring(internalData.componentClass))\n\n\terror(message, 0)\nend\n\n--[[\n\tRetrieves the context value corresponding to the given key. Can return nil\n\tif a requested context key is not present\n]]\nfunction Component:__getContext(key)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__getContext`\")\n\t\tinternalAssert(key ~= nil, \"Context key cannot be nil\")\n\tend\n\n\tlocal virtualNode = self[InternalData].virtualNode\n\tlocal context = virtualNode.context\n\n\treturn context[key]\nend\n\n--[[\n\tAdds a new context entry to this component's context table (which will be\n\tpassed down to child components).\n]]\nfunction Component:__addContext(key, value)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__addContext`\")\n\tend\n\tlocal virtualNode = self[InternalData].virtualNode\n\n\t-- Make sure we store a reference to the component's original, unmodified\n\t-- context the virtual node. In the reconciler, we'll restore the original\n\t-- context if we need to replace the node (this happens when a node gets\n\t-- re-rendered as a different component)\n\tif virtualNode.originalContext == nil then\n\t\tvirtualNode.originalContext = virtualNode.context\n\tend\n\n\t-- Build a new context table on top of the existing one, then apply it to\n\t-- our virtualNode\n\tlocal existing = virtualNode.context\n\tvirtualNode.context = assign({}, existing, { [key] = value })\nend\n\n--[[\n\tPerforms property validation if the static method validateProps is declared.\n\tvalidateProps should follow assert's expected arguments:\n\t(false, message: string) | true. The function may return a message in the\n\ttrue case; it will be ignored. If this fails, the function will throw the\n\terror.\n]]\nfunction Component:__validateProps(props)\n\tif not config.propValidation then\n\t\treturn\n\tend\n\n\tlocal validator = self[InternalData].componentClass.validateProps\n\n\tif validator == nil then\n\t\treturn\n\tend\n\n\tif typeof(validator) ~= \"function\" then\n\t\terror(\n\t\t\t(\"validateProps must be a function, but it is a %s.\\nCheck the definition of the component %q.\"):format(\n\t\t\t\ttypeof(validator),\n\t\t\t\tself.__componentName\n\t\t\t)\n\t\t)\n\tend\n\n\tlocal success, failureReason = validator(props)\n\n\tif not success then\n\t\tfailureReason = failureReason or \"<Validator function did not supply a message>\"\n\t\terror(\n\t\t\t(\"Property validation failed in %s: %s\\n\\n%s\"):format(\n\t\t\t\tself.__componentName,\n\t\t\t\ttostring(failureReason),\n\t\t\t\tself:getElementTraceback() or \"<enable element tracebacks>\"\n\t\t\t),\n\t\t\t0\n\t\t)\n\tend\nend\n\n--[[\n\tAn internal method used by the reconciler to construct a new component\n\tinstance and attach it to the given virtualNode.\n]]\nfunction Component:__mount(reconciler, virtualNode)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentClass, \"Invalid use of `__mount`\")\n\t\tinternalAssert(Type.of(virtualNode) == Type.VirtualNode, \"Expected arg #2 to be of type VirtualNode\")\n\tend\n\n\tlocal currentElement = virtualNode.currentElement\n\tlocal hostParent = virtualNode.hostParent\n\n\t-- Contains all the information that we want to keep from consumers of\n\t-- Roact, or even other parts of the codebase like the reconciler.\n\tlocal internalData = {\n\t\treconciler = reconciler,\n\t\tvirtualNode = virtualNode,\n\t\tcomponentClass = self,\n\t\tlifecyclePhase = ComponentLifecyclePhase.Init,\n\t\tpendingState = nil,\n\t}\n\n\tlocal instance = {\n\t\t[Type] = Type.StatefulComponentInstance,\n\t\t[InternalData] = internalData,\n\t}\n\n\tsetmetatable(instance, self)\n\n\tvirtualNode.instance = instance\n\n\tlocal props = currentElement.props\n\n\tif self.defaultProps ~= nil then\n\t\tprops = assign({}, self.defaultProps, props)\n\tend\n\n\tinstance:__validateProps(props)\n\n\tinstance.props = props\n\n\tlocal newContext = assign({}, virtualNode.legacyContext)\n\tinstance._context = newContext\n\n\tinstance.state = assign({}, instance:__getDerivedState(instance.props, {}))\n\n\tif instance.init ~= nil then\n\t\tinstance:init(instance.props)\n\t\tassign(instance.state, instance:__getDerivedState(instance.props, instance.state))\n\tend\n\n\t-- It's possible for init() to redefine _context!\n\tvirtualNode.legacyContext = instance._context\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.Render\n\tlocal renderResult = instance:render()\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren\n\treconciler.updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)\n\n\tif instance.didMount ~= nil then\n\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.DidMount\n\t\tinstance:didMount()\n\tend\n\n\tif internalData.pendingState ~= nil then\n\t\t-- __update will handle pendingState, so we don't pass any new element or state\n\t\tinstance:__update(nil, nil)\n\tend\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.Idle\nend\n\n--[[\n\tInternal method used by the reconciler to clean up any resources held by\n\tthis component instance.\n]]\nfunction Component:__unmount()\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__unmount`\")\n\tend\n\n\tlocal internalData = self[InternalData]\n\tlocal virtualNode = internalData.virtualNode\n\tlocal reconciler = internalData.reconciler\n\n\tif self.willUnmount ~= nil then\n\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.WillUnmount\n\t\tself:willUnmount()\n\tend\n\n\tfor _, childNode in pairs(virtualNode.children) do\n\t\treconciler.unmountVirtualNode(childNode)\n\tend\nend\n\n--[[\n\tInternal method used by setState (to trigger updates based on state) and by\n\tthe reconciler (to trigger updates based on props)\n\n\tReturns true if the update was completed, false if it was cancelled by shouldUpdate\n]]\nfunction Component:__update(updatedElement, updatedState)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__update`\")\n\t\tinternalAssert(\n\t\t\tType.of(updatedElement) == Type.Element or updatedElement == nil,\n\t\t\t\"Expected arg #1 to be of type Element or nil\"\n\t\t)\n\t\tinternalAssert(\n\t\t\ttypeof(updatedState) == \"table\" or updatedState == nil,\n\t\t\t\"Expected arg #2 to be of type table or nil\"\n\t\t)\n\tend\n\n\tlocal internalData = self[InternalData]\n\tlocal componentClass = internalData.componentClass\n\n\tlocal newProps = self.props\n\tif updatedElement ~= nil then\n\t\tnewProps = updatedElement.props\n\n\t\tif componentClass.defaultProps ~= nil then\n\t\t\tnewProps = assign({}, componentClass.defaultProps, newProps)\n\t\tend\n\n\t\tself:__validateProps(newProps)\n\tend\n\n\tlocal updateCount = 0\n\trepeat\n\t\tlocal finalState\n\t\tlocal pendingState = nil\n\n\t\t-- Consume any pending state we might have\n\t\tif internalData.pendingState ~= nil then\n\t\t\tpendingState = internalData.pendingState\n\t\t\tinternalData.pendingState = nil\n\t\tend\n\n\t\t-- Consume a standard update to state or props\n\t\tif updatedState ~= nil or newProps ~= self.props then\n\t\t\tif pendingState == nil then\n\t\t\t\tfinalState = updatedState or self.state\n\t\t\telse\n\t\t\t\tfinalState = assign(pendingState, updatedState)\n\t\t\tend\n\n\t\t\tlocal derivedState = self:__getDerivedState(newProps, finalState)\n\n\t\t\tif derivedState ~= nil then\n\t\t\t\tfinalState = assign({}, finalState, derivedState)\n\t\t\tend\n\n\t\t\tupdatedState = nil\n\t\telse\n\t\t\tfinalState = pendingState\n\t\tend\n\n\t\tif not self:__resolveUpdate(newProps, finalState) then\n\t\t\t-- If the update was short-circuited, bubble the result up to the caller\n\t\t\treturn false\n\t\tend\n\n\t\tupdateCount = updateCount + 1\n\n\t\tif updateCount > MAX_PENDING_UPDATES then\n\t\t\terror(tooManyUpdatesMessage:format(tostring(internalData.componentClass)), 3)\n\t\tend\n\tuntil internalData.pendingState == nil\n\n\treturn true\nend\n\n--[[\n\tInternal method used by __update to apply new props and state\n\n\tReturns true if the update was completed, false if it was cancelled by shouldUpdate\n]]\nfunction Component:__resolveUpdate(incomingProps, incomingState)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__resolveUpdate`\")\n\tend\n\n\tlocal internalData = self[InternalData]\n\tlocal virtualNode = internalData.virtualNode\n\tlocal reconciler = internalData.reconciler\n\n\tlocal oldProps = self.props\n\tlocal oldState = self.state\n\n\tif incomingProps == nil then\n\t\tincomingProps = oldProps\n\tend\n\tif incomingState == nil then\n\t\tincomingState = oldState\n\tend\n\n\tif self.shouldUpdate ~= nil then\n\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.ShouldUpdate\n\t\tlocal continueWithUpdate = self:shouldUpdate(incomingProps, incomingState)\n\n\t\tif not continueWithUpdate then\n\t\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.Idle\n\t\t\treturn false\n\t\tend\n\tend\n\n\tif self.willUpdate ~= nil then\n\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.WillUpdate\n\t\tself:willUpdate(incomingProps, incomingState)\n\tend\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.Render\n\n\tself.props = incomingProps\n\tself.state = incomingState\n\n\tlocal renderResult = virtualNode.instance:render()\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren\n\treconciler.updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, renderResult)\n\n\tif self.didUpdate ~= nil then\n\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.DidUpdate\n\t\tself:didUpdate(oldProps, oldState)\n\tend\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.Idle\n\treturn true\nend\n\nreturn Component\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "ComponentLifecyclePhase",
                            Source = 'local Symbol = require(script.Parent.Symbol)\nlocal strict = require(script.Parent.strict)\n\nlocal ComponentLifecyclePhase = strict({\n\t-- Component methods\n\tInit = Symbol.named("init"),\n\tRender = Symbol.named("render"),\n\tShouldUpdate = Symbol.named("shouldUpdate"),\n\tWillUpdate = Symbol.named("willUpdate"),\n\tDidMount = Symbol.named("didMount"),\n\tDidUpdate = Symbol.named("didUpdate"),\n\tWillUnmount = Symbol.named("willUnmount"),\n\n\t-- Phases describing reconciliation status\n\tReconcileChildren = Symbol.named("reconcileChildren"),\n\tIdle = Symbol.named("idle"),\n}, "ComponentLifecyclePhase")\n\nreturn ComponentLifecyclePhase\n'
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "Config",
                            Source = "--[[\n\tExposes an interface to set global configuration values for Roact.\n\n\tConfiguration can only occur once, and should only be done by an application\n\tusing Roact, not a library.\n\n\tAny keys that aren't recognized will cause errors. Configuration is only\n\tintended for configuring Roact itself, not extensions or libraries.\n\n\tConfiguration is expected to be set immediately after loading Roact. Setting\n\tconfiguration values after an application starts may produce unpredictable\n\tbehavior.\n]]\n\n-- Every valid configuration value should be non-nil in this table.\nlocal defaultConfig = {\n\t-- Enables asserts for internal Roact APIs. Useful for debugging Roact itself.\n\t[\"internalTypeChecks\"] = false,\n\t-- Enables stricter type asserts for Roact's public API.\n\t[\"typeChecks\"] = false,\n\t-- Enables storage of `debug.traceback()` values on elements for debugging.\n\t[\"elementTracing\"] = false,\n\t-- Enables validation of component props in stateful components.\n\t[\"propValidation\"] = false,\n}\n\n-- Build a list of valid configuration values up for debug messages.\nlocal defaultConfigKeys = {}\nfor key in pairs(defaultConfig) do\n\ttable.insert(defaultConfigKeys, key)\nend\n\nlocal Config = {}\n\nfunction Config.new()\n\tlocal self = {}\n\n\tself._currentConfig = setmetatable({}, {\n\t\t__index = function(_, key)\n\t\t\tlocal message = (\"Invalid global configuration key %q. Valid configuration keys are: %s\"):format(\n\t\t\t\ttostring(key),\n\t\t\t\ttable.concat(defaultConfigKeys, \", \")\n\t\t\t)\n\n\t\t\terror(message, 3)\n\t\tend,\n\t})\n\n\t-- We manually bind these methods here so that the Config's methods can be\n\t-- used without passing in self, since they eventually get exposed on the\n\t-- root Roact object.\n\tself.set = function(...)\n\t\treturn Config.set(self, ...)\n\tend\n\n\tself.get = function(...)\n\t\treturn Config.get(self, ...)\n\tend\n\n\tself.scoped = function(...)\n\t\treturn Config.scoped(self, ...)\n\tend\n\n\tself.set(defaultConfig)\n\n\treturn self\nend\n\nfunction Config:set(configValues)\n\t-- Validate values without changing any configuration.\n\t-- We only want to apply this configuration if it's valid!\n\tfor key, value in pairs(configValues) do\n\t\tif defaultConfig[key] == nil then\n\t\t\tlocal message = (\"Invalid global configuration key %q (type %s). Valid configuration keys are: %s\"):format(\n\t\t\t\ttostring(key),\n\t\t\t\ttypeof(key),\n\t\t\t\ttable.concat(defaultConfigKeys, \", \")\n\t\t\t)\n\n\t\t\terror(message, 3)\n\t\tend\n\n\t\t-- Right now, all configuration values must be boolean.\n\t\tif typeof(value) ~= \"boolean\" then\n\t\t\tlocal message = (\n\t\t\t\t\"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false\"\n\t\t\t):format(tostring(value), typeof(value), tostring(key))\n\n\t\t\terror(message, 3)\n\t\tend\n\n\t\tself._currentConfig[key] = value\n\tend\nend\n\nfunction Config:get()\n\treturn self._currentConfig\nend\n\nfunction Config:scoped(configValues, callback)\n\tlocal previousValues = {}\n\tfor key, value in pairs(self._currentConfig) do\n\t\tpreviousValues[key] = value\n\tend\n\n\tself.set(configValues)\n\n\tlocal success, result = pcall(callback)\n\n\tself.set(previousValues)\n\n\tassert(success, result)\nend\n\nreturn Config\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "ElementKind",
                            Source = '--[[\n\tContains markers for annotating the type of an element.\n\n\tUse `ElementKind` as a key, and values from it as the value.\n\n\t\tlocal element = {\n\t\t\t[ElementKind] = ElementKind.Host,\n\t\t}\n]]\n\nlocal Symbol = require(script.Parent.Symbol)\nlocal strict = require(script.Parent.strict)\nlocal Portal = require(script.Parent.Portal)\n\nlocal ElementKind = newproxy(true)\n\nlocal ElementKindInternal = {\n\tPortal = Symbol.named("Portal"),\n\tHost = Symbol.named("Host"),\n\tFunction = Symbol.named("Function"),\n\tStateful = Symbol.named("Stateful"),\n\tFragment = Symbol.named("Fragment"),\n}\n\nfunction ElementKindInternal.of(value)\n\tif typeof(value) ~= "table" then\n\t\treturn nil\n\tend\n\n\treturn value[ElementKind]\nend\n\nlocal componentTypesToKinds = {\n\t["string"] = ElementKindInternal.Host,\n\t["function"] = ElementKindInternal.Function,\n\t["table"] = ElementKindInternal.Stateful,\n}\n\nfunction ElementKindInternal.fromComponent(component)\n\tif component == Portal then\n\t\treturn ElementKind.Portal\n\telse\n\t\treturn componentTypesToKinds[typeof(component)]\n\tend\nend\n\ngetmetatable(ElementKind).__index = ElementKindInternal\n\nstrict(ElementKindInternal, "ElementKind")\n\nreturn ElementKind\n'
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "ElementUtils",
                            Source = "--!strict\nlocal Type = require(script.Parent.Type)\nlocal Symbol = require(script.Parent.Symbol)\n\nlocal function noop()\n\treturn nil\nend\n\nlocal ElementUtils = {}\n\n--[[\n\tA signal value indicating that a child should use its parent's key, because\n\tit has no key of its own.\n\n\tThis occurs when you return only one element from a function component or\n\tstateful render function.\n]]\nElementUtils.UseParentKey = Symbol.named(\"UseParentKey\")\n\ntype Iterator<K, V> = ({ [K]: V }, K?) -> (K?, V?)\ntype Element = { [any]: any }\n--[[\n\tReturns an iterator over the children of an element.\n\t`elementOrElements` may be one of:\n\t* a boolean\n\t* nil\n\t* a single element\n\t* a fragment\n\t* a table of elements\n\n\tIf `elementOrElements` is a boolean or nil, this will return an iterator with\n\tzero elements.\n\n\tIf `elementOrElements` is a single element, this will return an iterator with\n\tone element: a tuple where the first value is ElementUtils.UseParentKey, and\n\tthe second is the value of `elementOrElements`.\n\n\tIf `elementOrElements` is a fragment or a table, this will return an iterator\n\tover all the elements of the array.\n\n\tIf `elementOrElements` is none of the above, this function will throw.\n]]\nfunction ElementUtils.iterateElements<K>(elementOrElements): (Iterator<K, Element>, any, nil)\n\tlocal richType = Type.of(elementOrElements)\n\n\t-- Single child\n\tif richType == Type.Element then\n\t\tlocal called = false\n\n\t\treturn function(_, _)\n\t\t\tif called then\n\t\t\t\treturn nil\n\t\t\telse\n\t\t\t\tcalled = true\n\t\t\t\treturn ElementUtils.UseParentKey, elementOrElements\n\t\t\tend\n\t\tend\n\tend\n\n\tlocal regularType = typeof(elementOrElements)\n\n\tif elementOrElements == nil or regularType == \"boolean\" then\n\t\treturn (noop :: any) :: Iterator<K, Element>\n\tend\n\n\tif regularType == \"table\" then\n\t\treturn pairs(elementOrElements)\n\tend\n\n\terror(\"Invalid elements\")\nend\n\n--[[\n\tGets the child corresponding to a given key, respecting Roact's rules for\n\tchildren. Specifically:\n\t* If `elements` is nil or a boolean, this will return `nil`, regardless of\n\t\tthe key given.\n\t* If `elements` is a single element, this will return `nil`, unless the key\n\t\tis ElementUtils.UseParentKey.\n\t* If `elements` is a table of elements, this will return `elements[key]`.\n]]\nfunction ElementUtils.getElementByKey(elements, hostKey)\n\tif elements == nil or typeof(elements) == \"boolean\" then\n\t\treturn nil\n\tend\n\n\tif Type.of(elements) == Type.Element then\n\t\tif hostKey == ElementUtils.UseParentKey then\n\t\t\treturn elements\n\t\tend\n\n\t\treturn nil\n\tend\n\n\tif typeof(elements) == \"table\" then\n\t\treturn elements[hostKey]\n\tend\n\n\terror(\"Invalid elements\")\nend\n\nreturn ElementUtils\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "GlobalConfig",
                            Source = "--[[\n\tExposes a single instance of a configuration as Roact's GlobalConfig.\n]]\n\nlocal Config = require(script.Parent.Config)\n\nreturn Config.new()\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "Logging",
                            Source = '--[[\n\tCentralized place to handle logging. Lets us:\n\t- Unit test log output via `Logging.capture`\n\t- Disable verbose log messages when not debugging Roact\n\n\tThis should be broken out into a separate library with the addition of\n\tscoping and logging configuration.\n]]\n\n-- Determines whether log messages will go to stdout/stderr\nlocal outputEnabled = true\n\n-- A set of LogInfo objects that should have messages inserted into them.\n-- This is a set so that nested calls to Logging.capture will behave.\nlocal collectors = {}\n\n-- A set of all stack traces that have called warnOnce.\nlocal onceUsedLocations = {}\n\n--[[\n\tIndent a potentially multi-line string with the given number of tabs, in\n\taddition to any indentation the string already has.\n]]\nlocal function indent(source, indentLevel)\n\tlocal indentString = ("\\t"):rep(indentLevel)\n\n\treturn indentString .. source:gsub("\\n", "\\n" .. indentString)\nend\n\n--[[\n\tIndents a list of strings and then concatenates them together with newlines\n\tinto a single string.\n]]\nlocal function indentLines(lines, indentLevel)\n\tlocal outputBuffer = {}\n\n\tfor _, line in ipairs(lines) do\n\t\ttable.insert(outputBuffer, indent(line, indentLevel))\n\tend\n\n\treturn table.concat(outputBuffer, "\\n")\nend\n\nlocal logInfoMetatable = {}\n\n--[[\n\tAutomatic coercion to strings for LogInfo objects to enable debugging them\n\tmore easily.\n]]\nfunction logInfoMetatable:__tostring()\n\tlocal outputBuffer = { "LogInfo {" }\n\n\tlocal errorCount = #self.errors\n\tlocal warningCount = #self.warnings\n\tlocal infosCount = #self.infos\n\n\tif errorCount + warningCount + infosCount == 0 then\n\t\ttable.insert(outputBuffer, "\\t(no messages)")\n\tend\n\n\tif errorCount > 0 then\n\t\ttable.insert(outputBuffer, ("\\tErrors (%d) {"):format(errorCount))\n\t\ttable.insert(outputBuffer, indentLines(self.errors, 2))\n\t\ttable.insert(outputBuffer, "\\t}")\n\tend\n\n\tif warningCount > 0 then\n\t\ttable.insert(outputBuffer, ("\\tWarnings (%d) {"):format(warningCount))\n\t\ttable.insert(outputBuffer, indentLines(self.warnings, 2))\n\t\ttable.insert(outputBuffer, "\\t}")\n\tend\n\n\tif infosCount > 0 then\n\t\ttable.insert(outputBuffer, ("\\tInfos (%d) {"):format(infosCount))\n\t\ttable.insert(outputBuffer, indentLines(self.infos, 2))\n\t\ttable.insert(outputBuffer, "\\t}")\n\tend\n\n\ttable.insert(outputBuffer, "}")\n\n\treturn table.concat(outputBuffer, "\\n")\nend\n\nlocal function createLogInfo()\n\tlocal logInfo = {\n\t\terrors = {},\n\t\twarnings = {},\n\t\tinfos = {},\n\t}\n\n\tsetmetatable(logInfo, logInfoMetatable)\n\n\treturn logInfo\nend\n\nlocal Logging = {}\n\n--[[\n\tInvokes `callback`, capturing all output that happens during its execution.\n\n\tOutput will not go to stdout or stderr and will instead be put into a\n\tLogInfo object that is returned. If `callback` throws, the error will be\n\tbubbled up to the caller of `Logging.capture`.\n]]\nfunction Logging.capture(callback)\n\tlocal collector = createLogInfo()\n\n\tlocal wasOutputEnabled = outputEnabled\n\toutputEnabled = false\n\tcollectors[collector] = true\n\n\tlocal success, result = pcall(callback)\n\n\tcollectors[collector] = nil\n\toutputEnabled = wasOutputEnabled\n\n\tassert(success, result)\n\n\treturn collector\nend\n\n--[[\n\tIssues a warning with an automatically attached stack trace.\n]]\nfunction Logging.warn(messageTemplate, ...)\n\tlocal message = messageTemplate:format(...)\n\n\tfor collector in pairs(collectors) do\n\t\ttable.insert(collector.warnings, message)\n\tend\n\n\t-- debug.traceback inserts a leading newline, so we trim it here\n\tlocal trace = debug.traceback("", 2):sub(2)\n\tlocal fullMessage = ("%s\\n%s"):format(message, indent(trace, 1))\n\n\tif outputEnabled then\n\t\twarn(fullMessage)\n\tend\nend\n\n--[[\n\tIssues a warning like `Logging.warn`, but only outputs once per call site.\n\n\tThis is useful for marking deprecated functions that might be called a lot;\n\tusing `warnOnce` instead of `warn` will reduce output noise while still\n\tcorrectly marking all call sites.\n]]\nfunction Logging.warnOnce(messageTemplate, ...)\n\tlocal trace = debug.traceback()\n\n\tif onceUsedLocations[trace] then\n\t\treturn\n\tend\n\n\tonceUsedLocations[trace] = true\n\tLogging.warn(messageTemplate, ...)\nend\n\nreturn Logging\n'
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "None",
                            Source = 'local Symbol = require(script.Parent.Symbol)\n\n-- Marker used to specify that the value is nothing, because nil cannot be\n-- stored in tables.\nlocal None = Symbol.named("None")\n\nreturn None\n'
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "NoopRenderer",
                            Source = "--[[\n\tReference renderer intended for use in tests as well as for documenting the\n\tminimum required interface for a Roact renderer.\n]]\n\nlocal NoopRenderer = {}\n\nfunction NoopRenderer.isHostObject(target)\n\t-- Attempting to use NoopRenderer to target a Roblox instance is almost\n\t-- certainly a mistake.\n\treturn target == nil\nend\n\nfunction NoopRenderer.mountHostNode(_reconciler, _node) end\n\nfunction NoopRenderer.unmountHostNode(_reconciler, _node) end\n\nfunction NoopRenderer.updateHostNode(_reconciler, node, _newElement)\n\treturn node\nend\n\nreturn NoopRenderer\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "Portal",
                            Source = 'local Symbol = require(script.Parent.Symbol)\n\nlocal Portal = Symbol.named("Portal")\n\nreturn Portal\n'
                          }
                        }, {
                          Children = { {
                              Children = {},
                              Properties = {
                                ClassName = "ModuleScript",
                                Name = "Change",
                                Source = '--[[\n\tChange is used to generate special prop keys that can be used to connect to\n\tGetPropertyChangedSignal.\n\n\tGenerally, Change is indexed by a Roblox property name:\n\n\t\tRoact.createElement("TextBox", {\n\t\t\t[Roact.Change.Text] = function(rbx)\n\t\t\t\tprint("The TextBox", rbx, "changed text to", rbx.Text)\n\t\t\tend,\n\t\t})\n]]\n\nlocal Type = require(script.Parent.Parent.Type)\n\nlocal Change = {}\n\nlocal changeMetatable = {\n\t__tostring = function(self)\n\t\treturn ("RoactHostChangeEvent(%s)"):format(self.name)\n\tend,\n}\n\nsetmetatable(Change, {\n\t__index = function(_self, propertyName)\n\t\tlocal changeListener = {\n\t\t\t[Type] = Type.HostChangeEvent,\n\t\t\tname = propertyName,\n\t\t}\n\n\t\tsetmetatable(changeListener, changeMetatable)\n\t\tChange[propertyName] = changeListener\n\n\t\treturn changeListener\n\tend,\n})\n\nreturn Change\n'
                              }
                            }, {
                              Children = {},
                              Properties = {
                                ClassName = "ModuleScript",
                                Name = "Children",
                                Source = 'local Symbol = require(script.Parent.Parent.Symbol)\n\nlocal Children = Symbol.named("Children")\n\nreturn Children\n'
                              }
                            }, {
                              Children = {},
                              Properties = {
                                ClassName = "ModuleScript",
                                Name = "Event",
                                Source = '--[[\n\tIndex into `Event` to get a prop key for attaching to an event on a Roblox\n\tInstance.\n\n\tExample:\n\n\t\tRoact.createElement("TextButton", {\n\t\t\tText = "Hello, world!",\n\n\t\t\t[Roact.Event.MouseButton1Click] = function(rbx)\n\t\t\t\tprint("Clicked", rbx)\n\t\t\tend\n\t\t})\n]]\n\nlocal Type = require(script.Parent.Parent.Type)\n\nlocal Event = {}\n\nlocal eventMetatable = {\n\t__tostring = function(self)\n\t\treturn ("RoactHostEvent(%s)"):format(self.name)\n\tend,\n}\n\nsetmetatable(Event, {\n\t__index = function(_self, eventName)\n\t\tlocal event = {\n\t\t\t[Type] = Type.HostEvent,\n\t\t\tname = eventName,\n\t\t}\n\n\t\tsetmetatable(event, eventMetatable)\n\n\t\tEvent[eventName] = event\n\n\t\treturn event\n\tend,\n})\n\nreturn Event\n'
                              }
                            }, {
                              Children = {},
                              Properties = {
                                ClassName = "ModuleScript",
                                Name = "Ref",
                                Source = 'local Symbol = require(script.Parent.Parent.Symbol)\n\nlocal Ref = Symbol.named("Ref")\n\nreturn Ref\n'
                              }
                            } },
                          Properties = {
                            ClassName = "Folder",
                            Name = "PropMarkers"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "PureComponent",
                            Source = "--[[\n\tA version of Component with a `shouldUpdate` method that forces the\n\tresulting component to be pure.\n]]\n\nlocal Component = require(script.Parent.Component)\n\nlocal PureComponent = Component:extend(\"PureComponent\")\n\n-- When extend()ing a component, you don't get an extend method.\n-- This is to promote composition over inheritance.\n-- PureComponent is an exception to this rule.\nPureComponent.extend = Component.extend\n\nfunction PureComponent:shouldUpdate(newProps, newState)\n\t-- In a vast majority of cases, if state updated, something has updated.\n\t-- We don't bother checking in this case.\n\tif newState ~= self.state then\n\t\treturn true\n\tend\n\n\tif newProps == self.props then\n\t\treturn false\n\tend\n\n\tfor key, value in pairs(newProps) do\n\t\tif self.props[key] ~= value then\n\t\t\treturn true\n\t\tend\n\tend\n\n\tfor key, value in pairs(self.props) do\n\t\tif newProps[key] ~= value then\n\t\t\treturn true\n\t\tend\n\tend\n\n\treturn false\nend\n\nreturn PureComponent\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "assertDeepEqual",
                            Source = '--!strict\n--[[\n\tA utility used to assert that two objects are value-equal recursively. It\n\toutputs fairly nicely formatted messages to help diagnose why two objects\n\twould be different.\n\n\tThis should only be used in tests.\n]]\n\nlocal function deepEqual(a: any, b: any): (boolean, string?)\n\tif typeof(a) ~= typeof(b) then\n\t\tlocal message = ("{1} is of type %s, but {2} is of type %s"):format(typeof(a), typeof(b))\n\t\treturn false, message\n\tend\n\n\tif typeof(a) == "table" then\n\t\tlocal visitedKeys = {}\n\n\t\tfor key, value in pairs(a) do\n\t\t\tvisitedKeys[key] = true\n\n\t\t\tlocal success, innerMessage = deepEqual(value, b[key])\n\t\t\tif not success and innerMessage then\n\t\t\t\tlocal message = innerMessage\n\t\t\t\t\t:gsub("{1}", ("{1}[%s]"):format(tostring(key)))\n\t\t\t\t\t:gsub("{2}", ("{2}[%s]"):format(tostring(key)))\n\n\t\t\t\treturn false, message\n\t\t\tend\n\t\tend\n\n\t\tfor key, value in pairs(b) do\n\t\t\tif not visitedKeys[key] then\n\t\t\t\tlocal success, innerMessage = deepEqual(value, a[key])\n\n\t\t\t\tif not success and innerMessage then\n\t\t\t\t\tlocal message = innerMessage\n\t\t\t\t\t\t:gsub("{1}", ("{1}[%s]"):format(tostring(key)))\n\t\t\t\t\t\t:gsub("{2}", ("{2}[%s]"):format(tostring(key)))\n\n\t\t\t\t\treturn false, message\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\treturn true, nil\n\tend\n\n\tif a == b then\n\t\treturn true, nil\n\tend\n\n\tlocal message = "{1} ~= {2}"\n\treturn false, message\nend\n\nlocal function assertDeepEqual(a, b)\n\tlocal success, innerMessageTemplate = deepEqual(a, b)\n\n\tif not success and innerMessageTemplate then\n\t\tlocal innerMessage = innerMessageTemplate:gsub("{1}", "first"):gsub("{2}", "second")\n\n\t\tlocal message = ("Values were not deep-equal.\\n%s"):format(innerMessage)\n\n\t\terror(message, 2)\n\tend\nend\n\nreturn assertDeepEqual\n'
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "assign",
                            Source = "local None = require(script.Parent.None)\n\n--[[\n\tMerges values from zero or more tables onto a target table. If a value is\n\tset to None, it will instead be removed from the table.\n\n\tThis function is identical in functionality to JavaScript's Object.assign.\n]]\nlocal function assign(target, ...)\n\tfor index = 1, select(\"#\", ...) do\n\t\tlocal source = select(index, ...)\n\n\t\tif source ~= nil then\n\t\t\tfor key, value in pairs(source) do\n\t\t\t\tif value == None then\n\t\t\t\t\ttarget[key] = nil\n\t\t\t\telse\n\t\t\t\t\ttarget[key] = value\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\treturn target\nend\n\nreturn assign\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "createContext",
                            Source = "local Symbol = require(script.Parent.Symbol)\nlocal createFragment = require(script.Parent.createFragment)\nlocal createSignal = require(script.Parent.createSignal)\nlocal Children = require(script.Parent.PropMarkers.Children)\nlocal Component = require(script.Parent.Component)\n\n--[[\n\tConstruct the value that is assigned to Roact's context storage.\n]]\nlocal function createContextEntry(currentValue)\n\treturn {\n\t\tvalue = currentValue,\n\t\tonUpdate = createSignal(),\n\t}\nend\n\nlocal function createProvider(context)\n\tlocal Provider = Component:extend(\"Provider\")\n\n\tfunction Provider:init(props)\n\t\tself.contextEntry = createContextEntry(props.value)\n\t\tself:__addContext(context.key, self.contextEntry)\n\tend\n\n\tfunction Provider:willUpdate(nextProps)\n\t\t-- If the provided value changed, immediately update the context entry.\n\t\t--\n\t\t-- During this update, any components that are reachable will receive\n\t\t-- this updated value at the same time as any props and state updates\n\t\t-- that are being applied.\n\t\tif nextProps.value ~= self.props.value then\n\t\t\tself.contextEntry.value = nextProps.value\n\t\tend\n\tend\n\n\tfunction Provider:didUpdate(prevProps)\n\t\t-- If the provided value changed, after we've updated every reachable\n\t\t-- component, fire a signal to update the rest.\n\t\t--\n\t\t-- This signal will notify all context consumers. It's expected that\n\t\t-- they will compare the last context value they updated with and only\n\t\t-- trigger an update on themselves if this value is different.\n\t\t--\n\t\t-- This codepath will generally only update consumer components that has\n\t\t-- a component implementing shouldUpdate between them and the provider.\n\t\tif prevProps.value ~= self.props.value then\n\t\t\tself.contextEntry.onUpdate:fire(self.props.value)\n\t\tend\n\tend\n\n\tfunction Provider:render()\n\t\treturn createFragment(self.props[Children])\n\tend\n\n\treturn Provider\nend\n\nlocal function createConsumer(context)\n\tlocal Consumer = Component:extend(\"Consumer\")\n\n\tfunction Consumer.validateProps(props)\n\t\tif type(props.render) ~= \"function\" then\n\t\t\treturn false, \"Consumer expects a `render` function\"\n\t\telse\n\t\t\treturn true\n\t\tend\n\tend\n\n\tfunction Consumer:init(_props)\n\t\t-- This value may be nil, which indicates that our consumer is not a\n\t\t-- descendant of a provider for this context item.\n\t\tself.contextEntry = self:__getContext(context.key)\n\tend\n\n\tfunction Consumer:render()\n\t\t-- Render using the latest available for this context item.\n\t\t--\n\t\t-- We don't store this value in state in order to have more fine-grained\n\t\t-- control over our update behavior.\n\t\tlocal value\n\t\tif self.contextEntry ~= nil then\n\t\t\tvalue = self.contextEntry.value\n\t\telse\n\t\t\tvalue = context.defaultValue\n\t\tend\n\n\t\treturn self.props.render(value)\n\tend\n\n\tfunction Consumer:didUpdate()\n\t\t-- Store the value that we most recently updated with.\n\t\t--\n\t\t-- This value is compared in the contextEntry onUpdate hook below.\n\t\tif self.contextEntry ~= nil then\n\t\t\tself.lastValue = self.contextEntry.value\n\t\tend\n\tend\n\n\tfunction Consumer:didMount()\n\t\tif self.contextEntry ~= nil then\n\t\t\t-- When onUpdate is fired, a new value has been made available in\n\t\t\t-- this context entry, but we may have already updated in the same\n\t\t\t-- update cycle.\n\t\t\t--\n\t\t\t-- To avoid sending a redundant update, we compare the new value\n\t\t\t-- with the last value that we updated with (set in didUpdate) and\n\t\t\t-- only update if they differ. This may happen when an update from a\n\t\t\t-- provider was blocked by an intermediate component that returned\n\t\t\t-- false from shouldUpdate.\n\t\t\tself.disconnect = self.contextEntry.onUpdate:subscribe(function(newValue)\n\t\t\t\tif newValue ~= self.lastValue then\n\t\t\t\t\t-- Trigger a dummy state update.\n\t\t\t\t\tself:setState({})\n\t\t\t\tend\n\t\t\tend)\n\t\tend\n\tend\n\n\tfunction Consumer:willUnmount()\n\t\tif self.disconnect ~= nil then\n\t\t\tself.disconnect()\n\t\t\tself.disconnect = nil\n\t\tend\n\tend\n\n\treturn Consumer\nend\n\nlocal Context = {}\nContext.__index = Context\n\nfunction Context.new(defaultValue)\n\treturn setmetatable({\n\t\tdefaultValue = defaultValue,\n\t\tkey = Symbol.named(\"ContextKey\"),\n\t}, Context)\nend\n\nfunction Context:__tostring()\n\treturn \"RoactContext\"\nend\n\nlocal function createContext(defaultValue)\n\tlocal context = Context.new(defaultValue)\n\n\treturn {\n\t\tProvider = createProvider(context),\n\t\tConsumer = createConsumer(context),\n\t}\nend\n\nreturn createContext\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "createElement",
                            Source = "local Children = require(script.Parent.PropMarkers.Children)\nlocal ElementKind = require(script.Parent.ElementKind)\nlocal Logging = require(script.Parent.Logging)\nlocal Type = require(script.Parent.Type)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal multipleChildrenMessage = [[\nThe prop `Roact.Children` was defined but was overridden by the third parameter to createElement!\nThis can happen when a component passes props through to a child element but also uses the `children` argument:\n\n\tRoact.createElement(\"Frame\", passedProps, {\n\t\tchild = ...\n\t})\n\nInstead, consider using a utility function to merge tables of children together:\n\n\tlocal children = mergeTables(passedProps[Roact.Children], {\n\t\tchild = ...\n\t})\n\n\tlocal fullProps = mergeTables(passedProps, {\n\t\t[Roact.Children] = children\n\t})\n\n\tRoact.createElement(\"Frame\", fullProps)]]\n\n--[[\n\tCreates a new element representing the given component.\n\n\tElements are lightweight representations of what a component instance should\n\tlook like.\n\n\tChildren is a shorthand for specifying `Roact.Children` as a key inside\n\tprops. If specified, the passed `props` table is mutated!\n]]\nlocal function createElement(component, props, children)\n\tif config.typeChecks then\n\t\tassert(component ~= nil, \"`component` is required\")\n\t\tassert(typeof(props) == \"table\" or props == nil, \"`props` must be a table or nil\")\n\t\tassert(typeof(children) == \"table\" or children == nil, \"`children` must be a table or nil\")\n\tend\n\n\tif props == nil then\n\t\tprops = {}\n\tend\n\n\tif children ~= nil then\n\t\tif props[Children] ~= nil then\n\t\t\tLogging.warnOnce(multipleChildrenMessage)\n\t\tend\n\n\t\tprops[Children] = children\n\tend\n\n\tlocal elementKind = ElementKind.fromComponent(component)\n\n\tlocal element = {\n\t\t[Type] = Type.Element,\n\t\t[ElementKind] = elementKind,\n\t\tcomponent = component,\n\t\tprops = props,\n\t}\n\n\tif config.elementTracing then\n\t\t-- We trim out the leading newline since there's no way to specify the\n\t\t-- trace level without also specifying a message.\n\t\telement.source = debug.traceback(\"\", 2):sub(2)\n\tend\n\n\treturn element\nend\n\nreturn createElement\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "createFragment",
                            Source = "local ElementKind = require(script.Parent.ElementKind)\nlocal Type = require(script.Parent.Type)\n\nlocal function createFragment(elements)\n\treturn {\n\t\t[Type] = Type.Element,\n\t\t[ElementKind] = ElementKind.Fragment,\n\t\telements = elements,\n\t}\nend\n\nreturn createFragment\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "createReconciler",
                            Source = "--!nonstrict\nlocal Type = require(script.Parent.Type)\nlocal ElementKind = require(script.Parent.ElementKind)\nlocal ElementUtils = require(script.Parent.ElementUtils)\nlocal Children = require(script.Parent.PropMarkers.Children)\nlocal Symbol = require(script.Parent.Symbol)\nlocal internalAssert = require(script.Parent.internalAssert)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal InternalData = Symbol.named(\"InternalData\")\n\n--[[\n\tThe reconciler is the mechanism in Roact that constructs the virtual tree\n\tthat later gets turned into concrete objects by the renderer.\n\n\tRoact's reconciler is constructed with the renderer as an argument, which\n\tenables switching to different renderers for different platforms or\n\tscenarios.\n\n\tWhen testing the reconciler itself, it's common to use `NoopRenderer` with\n\tspies replacing some methods. The default (and only) reconciler interface\n\texposed by Roact right now uses `RobloxRenderer`.\n]]\nlocal function createReconciler(renderer)\n\tlocal reconciler\n\tlocal mountVirtualNode\n\tlocal updateVirtualNode\n\tlocal unmountVirtualNode\n\n\t--[[\n\t\tUnmount the given virtualNode, replacing it with a new node described by\n\t\tthe given element.\n\n\t\tPreserves host properties, depth, and legacyContext from parent.\n\t]]\n\tlocal function replaceVirtualNode(virtualNode, newElement)\n\t\tlocal hostParent = virtualNode.hostParent\n\t\tlocal hostKey = virtualNode.hostKey\n\t\tlocal depth = virtualNode.depth\n\t\tlocal parent = virtualNode.parent\n\n\t\t-- If the node that is being replaced has modified context, we need to\n\t\t-- use the original *unmodified* context for the new node\n\t\t-- The `originalContext` field will be nil if the context was unchanged\n\t\tlocal context = virtualNode.originalContext or virtualNode.context\n\t\tlocal parentLegacyContext = virtualNode.parentLegacyContext\n\n\t\t-- If updating this node has caused a component higher up the tree to re-render\n\t\t-- and updateChildren to be re-entered then this node could already have been\n\t\t-- unmounted in the previous updateChildren pass.\n\t\tif not virtualNode.wasUnmounted then\n\t\t\tunmountVirtualNode(virtualNode)\n\t\tend\n\t\tlocal newNode = mountVirtualNode(newElement, hostParent, hostKey, context, parentLegacyContext)\n\n\t\t-- mountVirtualNode can return nil if the element is a boolean\n\t\tif newNode ~= nil then\n\t\t\tnewNode.depth = depth\n\t\t\tnewNode.parent = parent\n\t\tend\n\n\t\treturn newNode\n\tend\n\n\t--[[\n\t\tUtility to update the children of a virtual node based on zero or more\n\t\tupdated children given as elements.\n\t]]\n\tlocal function updateChildren(virtualNode, hostParent, newChildElements)\n\t\tif config.internalTypeChecks then\n\t\t\tinternalAssert(Type.of(virtualNode) == Type.VirtualNode, \"Expected arg #1 to be of type VirtualNode\")\n\t\tend\n\n\t\tvirtualNode.updateChildrenCount = virtualNode.updateChildrenCount + 1\n\n\t\tlocal currentUpdateChildrenCount = virtualNode.updateChildrenCount\n\n\t\tlocal removeKeys = {}\n\n\t\t-- Changed or removed children\n\t\tfor childKey, childNode in pairs(virtualNode.children) do\n\t\t\tlocal newElement = ElementUtils.getElementByKey(newChildElements, childKey)\n\t\t\tlocal newNode = updateVirtualNode(childNode, newElement)\n\n\t\t\t-- If updating this node has caused a component higher up the tree to re-render\n\t\t\t-- and updateChildren to be re-entered for this virtualNode then\n\t\t\t-- this result is invalid and needs to be disgarded.\n\t\t\tif virtualNode.updateChildrenCount ~= currentUpdateChildrenCount then\n\t\t\t\tif newNode and newNode ~= virtualNode.children[childKey] then\n\t\t\t\t\tunmountVirtualNode(newNode)\n\t\t\t\tend\n\t\t\t\treturn\n\t\t\tend\n\n\t\t\tif newNode ~= nil then\n\t\t\t\tvirtualNode.children[childKey] = newNode\n\t\t\telse\n\t\t\t\tremoveKeys[childKey] = true\n\t\t\tend\n\t\tend\n\n\t\tfor childKey in pairs(removeKeys) do\n\t\t\tvirtualNode.children[childKey] = nil\n\t\tend\n\n\t\t-- Added children\n\t\tfor childKey, newElement in ElementUtils.iterateElements(newChildElements) do\n\t\t\tlocal concreteKey = childKey\n\t\t\tif childKey == ElementUtils.UseParentKey then\n\t\t\t\tconcreteKey = virtualNode.hostKey\n\t\t\tend\n\n\t\t\tif virtualNode.children[childKey] == nil then\n\t\t\t\tlocal childNode = mountVirtualNode(\n\t\t\t\t\tnewElement,\n\t\t\t\t\thostParent,\n\t\t\t\t\tconcreteKey,\n\t\t\t\t\tvirtualNode.context,\n\t\t\t\t\tvirtualNode.legacyContext\n\t\t\t\t)\n\n\t\t\t\t-- If updating this node has caused a component higher up the tree to re-render\n\t\t\t\t-- and updateChildren to be re-entered for this virtualNode then\n\t\t\t\t-- this result is invalid and needs to be discarded.\n\t\t\t\tif virtualNode.updateChildrenCount ~= currentUpdateChildrenCount then\n\t\t\t\t\tif childNode then\n\t\t\t\t\t\tunmountVirtualNode(childNode)\n\t\t\t\t\tend\n\t\t\t\t\treturn\n\t\t\t\tend\n\n\t\t\t\t-- mountVirtualNode can return nil if the element is a boolean\n\t\t\t\tif childNode ~= nil then\n\t\t\t\t\tchildNode.depth = virtualNode.depth + 1\n\t\t\t\t\tchildNode.parent = virtualNode\n\t\t\t\t\tvirtualNode.children[childKey] = childNode\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tlocal function updateVirtualNodeWithChildren(virtualNode, hostParent, newChildElements)\n\t\tupdateChildren(virtualNode, hostParent, newChildElements)\n\tend\n\n\tlocal function updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)\n\t\tif Type.of(renderResult) == Type.Element or renderResult == nil or typeof(renderResult) == \"boolean\" then\n\t\t\tupdateChildren(virtualNode, hostParent, renderResult)\n\t\telse\n\t\t\terror(\n\t\t\t\t(\"%s\\n%s\"):format(\n\t\t\t\t\t\"Component returned invalid children:\",\n\t\t\t\t\tvirtualNode.currentElement.source or \"<enable element tracebacks>\"\n\t\t\t\t),\n\t\t\t\t0\n\t\t\t)\n\t\tend\n\tend\n\n\t--[[\n\t\tUnmounts the given virtual node and releases any held resources.\n\t]]\n\tfunction unmountVirtualNode(virtualNode)\n\t\tif config.internalTypeChecks then\n\t\t\tinternalAssert(Type.of(virtualNode) == Type.VirtualNode, \"Expected arg #1 to be of type VirtualNode\")\n\t\tend\n\n\t\tvirtualNode.wasUnmounted = true\n\n\t\tlocal kind = ElementKind.of(virtualNode.currentElement)\n\n\t\t-- selene: allow(if_same_then_else)\n\t\tif kind == ElementKind.Host then\n\t\t\trenderer.unmountHostNode(reconciler, virtualNode)\n\t\telseif kind == ElementKind.Function then\n\t\t\tfor _, childNode in pairs(virtualNode.children) do\n\t\t\t\tunmountVirtualNode(childNode)\n\t\t\tend\n\t\telseif kind == ElementKind.Stateful then\n\t\t\tvirtualNode.instance:__unmount()\n\t\telseif kind == ElementKind.Portal then\n\t\t\tfor _, childNode in pairs(virtualNode.children) do\n\t\t\t\tunmountVirtualNode(childNode)\n\t\t\tend\n\t\telseif kind == ElementKind.Fragment then\n\t\t\tfor _, childNode in pairs(virtualNode.children) do\n\t\t\t\tunmountVirtualNode(childNode)\n\t\t\tend\n\t\telse\n\t\t\terror((\"Unknown ElementKind %q\"):format(tostring(kind)), 2)\n\t\tend\n\tend\n\n\tlocal function updateFunctionVirtualNode(virtualNode, newElement)\n\t\tlocal children = newElement.component(newElement.props)\n\n\t\tupdateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)\n\n\t\treturn virtualNode\n\tend\n\n\tlocal function updatePortalVirtualNode(virtualNode, newElement)\n\t\tlocal oldElement = virtualNode.currentElement\n\t\tlocal oldTargetHostParent = oldElement.props.target\n\n\t\tlocal targetHostParent = newElement.props.target\n\n\t\tassert(renderer.isHostObject(targetHostParent), \"Expected target to be host object\")\n\n\t\tif targetHostParent ~= oldTargetHostParent then\n\t\t\treturn replaceVirtualNode(virtualNode, newElement)\n\t\tend\n\n\t\tlocal children = newElement.props[Children]\n\n\t\tupdateVirtualNodeWithChildren(virtualNode, targetHostParent, children)\n\n\t\treturn virtualNode\n\tend\n\n\tlocal function updateFragmentVirtualNode(virtualNode, newElement)\n\t\tupdateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, newElement.elements)\n\n\t\treturn virtualNode\n\tend\n\n\t--[[\n\t\tUpdate the given virtual node using a new element describing what it\n\t\tshould transform into.\n\n\t\t`updateVirtualNode` will return a new virtual node that should replace\n\t\tthe passed in virtual node. This is because a virtual node can be\n\t\tupdated with an element referencing a different component!\n\n\t\tIn that case, `updateVirtualNode` will unmount the input virtual node,\n\t\tmount a new virtual node, and return it in this case, while also issuing\n\t\ta warning to the user.\n\t]]\n\tfunction updateVirtualNode(virtualNode, newElement, newState: { [any]: any }?): { [any]: any }?\n\t\tif config.internalTypeChecks then\n\t\t\tinternalAssert(Type.of(virtualNode) == Type.VirtualNode, \"Expected arg #1 to be of type VirtualNode\")\n\t\tend\n\t\tif config.typeChecks then\n\t\t\tassert(\n\t\t\t\tType.of(newElement) == Type.Element or typeof(newElement) == \"boolean\" or newElement == nil,\n\t\t\t\t\"Expected arg #2 to be of type Element, boolean, or nil\"\n\t\t\t)\n\t\tend\n\n\t\t-- If nothing changed, we can skip this update\n\t\tif virtualNode.currentElement == newElement and newState == nil then\n\t\t\treturn virtualNode\n\t\tend\n\n\t\tif typeof(newElement) == \"boolean\" or newElement == nil then\n\t\t\tunmountVirtualNode(virtualNode)\n\t\t\treturn nil\n\t\tend\n\n\t\tif virtualNode.currentElement.component ~= newElement.component then\n\t\t\treturn replaceVirtualNode(virtualNode, newElement)\n\t\tend\n\n\t\tlocal kind = ElementKind.of(newElement)\n\n\t\tlocal shouldContinueUpdate = true\n\n\t\tif kind == ElementKind.Host then\n\t\t\tvirtualNode = renderer.updateHostNode(reconciler, virtualNode, newElement)\n\t\telseif kind == ElementKind.Function then\n\t\t\tvirtualNode = updateFunctionVirtualNode(virtualNode, newElement)\n\t\telseif kind == ElementKind.Stateful then\n\t\t\tshouldContinueUpdate = virtualNode.instance:__update(newElement, newState)\n\t\telseif kind == ElementKind.Portal then\n\t\t\tvirtualNode = updatePortalVirtualNode(virtualNode, newElement)\n\t\telseif kind == ElementKind.Fragment then\n\t\t\tvirtualNode = updateFragmentVirtualNode(virtualNode, newElement)\n\t\telse\n\t\t\terror((\"Unknown ElementKind %q\"):format(tostring(kind)), 2)\n\t\tend\n\n\t\t-- Stateful components can abort updates via shouldUpdate. If that\n\t\t-- happens, we should stop doing stuff at this point.\n\t\tif not shouldContinueUpdate then\n\t\t\treturn virtualNode\n\t\tend\n\n\t\tvirtualNode.currentElement = newElement\n\n\t\treturn virtualNode\n\tend\n\n\t--[[\n\t\tConstructs a new virtual node but not does mount it.\n\t]]\n\tlocal function createVirtualNode(element, hostParent, hostKey, context, legacyContext)\n\t\tif config.internalTypeChecks then\n\t\t\tinternalAssert(\n\t\t\t\trenderer.isHostObject(hostParent) or hostParent == nil,\n\t\t\t\t\"Expected arg #2 to be a host object\"\n\t\t\t)\n\t\t\tinternalAssert(typeof(context) == \"table\" or context == nil, \"Expected arg #4 to be of type table or nil\")\n\t\t\tinternalAssert(\n\t\t\t\ttypeof(legacyContext) == \"table\" or legacyContext == nil,\n\t\t\t\t\"Expected arg #5 to be of type table or nil\"\n\t\t\t)\n\t\tend\n\t\tif config.typeChecks then\n\t\t\tassert(hostKey ~= nil, \"Expected arg #3 to be non-nil\")\n\t\t\tassert(\n\t\t\t\tType.of(element) == Type.Element or typeof(element) == \"boolean\",\n\t\t\t\t\"Expected arg #1 to be of type Element or boolean\"\n\t\t\t)\n\t\tend\n\n\t\treturn {\n\t\t\t[Type] = Type.VirtualNode,\n\t\t\tcurrentElement = element,\n\t\t\tdepth = 1,\n\t\t\tparent = nil,\n\t\t\tchildren = {},\n\t\t\thostParent = hostParent,\n\t\t\thostKey = hostKey,\n\t\t\tupdateChildrenCount = 0,\n\t\t\twasUnmounted = false,\n\n\t\t\t-- Legacy Context API\n\t\t\t-- A table of context values inherited from the parent node\n\t\t\tlegacyContext = legacyContext,\n\n\t\t\t-- A saved copy of the parent context, used when replacing a node\n\t\t\tparentLegacyContext = legacyContext,\n\n\t\t\t-- Context API\n\t\t\t-- A table of context values inherited from the parent node\n\t\t\tcontext = context or {},\n\n\t\t\t-- A saved copy of the unmodified context; this will be updated when\n\t\t\t-- a component adds new context and used when a node is replaced\n\t\t\toriginalContext = nil,\n\t\t}\n\tend\n\n\tlocal function mountFunctionVirtualNode(virtualNode)\n\t\tlocal element = virtualNode.currentElement\n\n\t\tlocal children = element.component(element.props)\n\n\t\tupdateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)\n\tend\n\n\tlocal function mountPortalVirtualNode(virtualNode)\n\t\tlocal element = virtualNode.currentElement\n\n\t\tlocal targetHostParent = element.props.target\n\t\tlocal children = element.props[Children]\n\n\t\tassert(renderer.isHostObject(targetHostParent), \"Expected target to be host object\")\n\n\t\tupdateVirtualNodeWithChildren(virtualNode, targetHostParent, children)\n\tend\n\n\tlocal function mountFragmentVirtualNode(virtualNode)\n\t\tlocal element = virtualNode.currentElement\n\t\tlocal children = element.elements\n\n\t\tupdateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, children)\n\tend\n\n\t--[[\n\t\tConstructs a new virtual node and mounts it, but does not place it into\n\t\tthe tree.\n\t]]\n\tfunction mountVirtualNode(element, hostParent, hostKey, context, legacyContext)\n\t\tif config.internalTypeChecks then\n\t\t\tinternalAssert(\n\t\t\t\trenderer.isHostObject(hostParent) or hostParent == nil,\n\t\t\t\t\"Expected arg #2 to be a host object\"\n\t\t\t)\n\t\t\tinternalAssert(\n\t\t\t\ttypeof(legacyContext) == \"table\" or legacyContext == nil,\n\t\t\t\t\"Expected arg #5 to be of type table or nil\"\n\t\t\t)\n\t\tend\n\t\tif config.typeChecks then\n\t\t\tassert(hostKey ~= nil, \"Expected arg #3 to be non-nil\")\n\t\t\tassert(\n\t\t\t\tType.of(element) == Type.Element or typeof(element) == \"boolean\",\n\t\t\t\t\"Expected arg #1 to be of type Element or boolean\"\n\t\t\t)\n\t\tend\n\n\t\t-- Boolean values render as nil to enable terse conditional rendering.\n\t\tif typeof(element) == \"boolean\" then\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal kind = ElementKind.of(element)\n\n\t\tlocal virtualNode = createVirtualNode(element, hostParent, hostKey, context, legacyContext)\n\n\t\tif kind == ElementKind.Host then\n\t\t\trenderer.mountHostNode(reconciler, virtualNode)\n\t\telseif kind == ElementKind.Function then\n\t\t\tmountFunctionVirtualNode(virtualNode)\n\t\telseif kind == ElementKind.Stateful then\n\t\t\telement.component:__mount(reconciler, virtualNode)\n\t\telseif kind == ElementKind.Portal then\n\t\t\tmountPortalVirtualNode(virtualNode)\n\t\telseif kind == ElementKind.Fragment then\n\t\t\tmountFragmentVirtualNode(virtualNode)\n\t\telse\n\t\t\terror((\"Unknown ElementKind %q\"):format(tostring(kind)), 2)\n\t\tend\n\n\t\treturn virtualNode\n\tend\n\n\t--[[\n\t\tConstructs a new Roact virtual tree, constructs a root node for\n\t\tit, and mounts it.\n\t]]\n\tlocal function mountVirtualTree(element, hostParent, hostKey)\n\t\tif config.typeChecks then\n\t\t\tassert(Type.of(element) == Type.Element, \"Expected arg #1 to be of type Element\")\n\t\t\tassert(renderer.isHostObject(hostParent) or hostParent == nil, \"Expected arg #2 to be a host object\")\n\t\tend\n\n\t\tif hostKey == nil then\n\t\t\thostKey = \"RoactTree\"\n\t\tend\n\n\t\tlocal tree = {\n\t\t\t[Type] = Type.VirtualTree,\n\t\t\t[InternalData] = {\n\t\t\t\t-- The root node of the tree, which starts into the hierarchy of\n\t\t\t\t-- Roact component instances.\n\t\t\t\trootNode = nil,\n\t\t\t\tmounted = true,\n\t\t\t},\n\t\t}\n\n\t\ttree[InternalData].rootNode = mountVirtualNode(element, hostParent, hostKey)\n\n\t\treturn tree\n\tend\n\n\t--[[\n\t\tUnmounts the virtual tree, freeing all of its resources.\n\n\t\tNo further operations should be done on the tree after it's been\n\t\tunmounted, as indicated by its the `mounted` field.\n\t]]\n\tlocal function unmountVirtualTree(tree)\n\t\tlocal internalData = tree[InternalData]\n\t\tif config.typeChecks then\n\t\t\tassert(Type.of(tree) == Type.VirtualTree, \"Expected arg #1 to be a Roact handle\")\n\t\t\tassert(internalData.mounted, \"Cannot unmounted a Roact tree that has already been unmounted\")\n\t\tend\n\n\t\tinternalData.mounted = false\n\n\t\tif internalData.rootNode ~= nil then\n\t\t\tunmountVirtualNode(internalData.rootNode)\n\t\tend\n\tend\n\n\t--[[\n\t\tUtility method for updating the root node of a virtual tree given a new\n\t\telement.\n\t]]\n\tlocal function updateVirtualTree(tree, newElement)\n\t\tlocal internalData = tree[InternalData]\n\t\tif config.typeChecks then\n\t\t\tassert(Type.of(tree) == Type.VirtualTree, \"Expected arg #1 to be a Roact handle\")\n\t\t\tassert(Type.of(newElement) == Type.Element, \"Expected arg #2 to be a Roact Element\")\n\t\tend\n\n\t\tinternalData.rootNode = updateVirtualNode(internalData.rootNode, newElement)\n\n\t\treturn tree\n\tend\n\n\treconciler = {\n\t\tmountVirtualTree = mountVirtualTree,\n\t\tunmountVirtualTree = unmountVirtualTree,\n\t\tupdateVirtualTree = updateVirtualTree,\n\n\t\tcreateVirtualNode = createVirtualNode,\n\t\tmountVirtualNode = mountVirtualNode,\n\t\tunmountVirtualNode = unmountVirtualNode,\n\t\tupdateVirtualNode = updateVirtualNode,\n\t\tupdateVirtualNodeWithChildren = updateVirtualNodeWithChildren,\n\t\tupdateVirtualNodeWithRenderResult = updateVirtualNodeWithRenderResult,\n\t}\n\n\treturn reconciler\nend\n\nreturn createReconciler\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "createReconcilerCompat",
                            Source = "--[[\n\tContains deprecated methods from Reconciler. Broken out so that removing\n\tthis shim is easy -- just delete this file and remove it from init.\n]]\n\nlocal Logging = require(script.Parent.Logging)\n\nlocal reifyMessage = [[\nRoact.reify has been renamed to Roact.mount and will be removed in a future release.\nCheck the call to Roact.reify at:\n]]\n\nlocal teardownMessage = [[\nRoact.teardown has been renamed to Roact.unmount and will be removed in a future release.\nCheck the call to Roact.teardown at:\n]]\n\nlocal reconcileMessage = [[\nRoact.reconcile has been renamed to Roact.update and will be removed in a future release.\nCheck the call to Roact.reconcile at:\n]]\n\nlocal function createReconcilerCompat(reconciler)\n\tlocal compat = {}\n\n\tfunction compat.reify(...)\n\t\tLogging.warnOnce(reifyMessage)\n\n\t\treturn reconciler.mountVirtualTree(...)\n\tend\n\n\tfunction compat.teardown(...)\n\t\tLogging.warnOnce(teardownMessage)\n\n\t\treturn reconciler.unmountVirtualTree(...)\n\tend\n\n\tfunction compat.reconcile(...)\n\t\tLogging.warnOnce(reconcileMessage)\n\n\t\treturn reconciler.updateVirtualTree(...)\n\tend\n\n\treturn compat\nend\n\nreturn createReconcilerCompat\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "createRef",
                            Source = "--[[\n\tA ref is nothing more than a binding with a special field 'current'\n\tthat maps to the getValue method of the binding\n]]\nlocal Binding = require(script.Parent.Binding)\n\nlocal function createRef()\n\tlocal binding, _ = Binding.create(nil)\n\n\tlocal ref = {}\n\n\t--[[\n\t\tA ref is just redirected to a binding via its metatable\n\t]]\n\tsetmetatable(ref, {\n\t\t__index = function(_self, key)\n\t\t\tif key == \"current\" then\n\t\t\t\treturn binding:getValue()\n\t\t\telse\n\t\t\t\treturn binding[key]\n\t\t\tend\n\t\tend,\n\t\t__newindex = function(_self, key, value)\n\t\t\tif key == \"current\" then\n\t\t\t\terror(\"Cannot assign to the 'current' property of refs\", 2)\n\t\t\tend\n\n\t\t\tbinding[key] = value\n\t\tend,\n\t\t__tostring = function(_self)\n\t\t\treturn (\"RoactRef(%s)\"):format(tostring(binding:getValue()))\n\t\tend,\n\t})\n\n\treturn ref\nend\n\nreturn createRef\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "createSignal",
                            Source = "--[[\n\tThis is a simple signal implementation that has a dead-simple API.\n\n\t\tlocal signal = createSignal()\n\n\t\tlocal disconnect = signal:subscribe(function(foo)\n\t\t\tprint(\"Cool foo:\", foo)\n\t\tend)\n\n\t\tsignal:fire(\"something\")\n\n\t\tdisconnect()\n]]\n\nlocal function createSignal()\n\tlocal connections = {}\n\tlocal suspendedConnections = {}\n\tlocal firing = false\n\n\tlocal function subscribe(_self, callback)\n\t\tassert(typeof(callback) == \"function\", \"Can only subscribe to signals with a function.\")\n\n\t\tlocal connection = {\n\t\t\tcallback = callback,\n\t\t\tdisconnected = false,\n\t\t}\n\n\t\t-- If the callback is already registered, don't add to the suspendedConnection. Otherwise, this will disable\n\t\t-- the existing one.\n\t\tif firing and not connections[callback] then\n\t\t\tsuspendedConnections[callback] = connection\n\t\tend\n\n\t\tconnections[callback] = connection\n\n\t\tlocal function disconnect()\n\t\t\tassert(not connection.disconnected, \"Listeners can only be disconnected once.\")\n\n\t\t\tconnection.disconnected = true\n\t\t\tconnections[callback] = nil\n\t\t\tsuspendedConnections[callback] = nil\n\t\tend\n\n\t\treturn disconnect\n\tend\n\n\tlocal function fire(_self, ...)\n\t\tfiring = true\n\t\tfor callback, connection in pairs(connections) do\n\t\t\tif not connection.disconnected and not suspendedConnections[callback] then\n\t\t\t\tcallback(...)\n\t\t\tend\n\t\tend\n\n\t\tfiring = false\n\n\t\tfor callback, _ in pairs(suspendedConnections) do\n\t\t\tsuspendedConnections[callback] = nil\n\t\tend\n\tend\n\n\treturn {\n\t\tsubscribe = subscribe,\n\t\tfire = fire,\n\t}\nend\n\nreturn createSignal\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "createSpy",
                            Source = '--[[\n\tA utility used to create a function spy that can be used to robustly test\n\tthat functions are invoked the correct number of times and with the correct\n\tnumber of arguments.\n\n\tThis should only be used in tests.\n]]\n\nlocal assertDeepEqual = require(script.Parent.assertDeepEqual)\n\nlocal function createSpy(inner)\n\tlocal self = {}\n\tself.callCount = 0\n\tself.values = {}\n\tself.valuesLength = 0\n\tself.value = function(...)\n\t\tself.callCount = self.callCount + 1\n\t\tself.values = { ... }\n\t\tself.valuesLength = select("#", ...)\n\n\t\tif inner ~= nil then\n\t\t\treturn inner(...)\n\t\tend\n\t\treturn nil\n\tend\n\n\tself.assertCalledWith = function(_, ...)\n\t\tlocal len = select("#", ...)\n\n\t\tif self.valuesLength ~= len then\n\t\t\terror(("Expected %d arguments, but was called with %d arguments"):format(self.valuesLength, len), 2)\n\t\tend\n\n\t\tfor i = 1, len do\n\t\t\tlocal expected = select(i, ...)\n\n\t\t\tassert(self.values[i] == expected, "value differs")\n\t\tend\n\tend\n\n\tself.assertCalledWithDeepEqual = function(_, ...)\n\t\tlocal len = select("#", ...)\n\n\t\tif self.valuesLength ~= len then\n\t\t\terror(("Expected %d arguments, but was called with %d arguments"):format(self.valuesLength, len), 2)\n\t\tend\n\n\t\tfor i = 1, len do\n\t\t\tlocal expected = select(i, ...)\n\n\t\t\tassertDeepEqual(self.values[i], expected)\n\t\tend\n\tend\n\n\tself.captureValues = function(_, ...)\n\t\tlocal len = select("#", ...)\n\t\tlocal result = {}\n\n\t\tassert(self.valuesLength == len, "length of expected values differs from stored values")\n\n\t\tfor i = 1, len do\n\t\t\tlocal key = select(i, ...)\n\t\t\tresult[key] = self.values[i]\n\t\tend\n\n\t\treturn result\n\tend\n\n\tsetmetatable(self, {\n\t\t__index = function(_, key)\n\t\t\terror(("%q is not a valid member of spy"):format(key))\n\t\tend,\n\t})\n\n\treturn self\nend\n\nreturn createSpy\n'
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "forwardRef",
                            Source = 'local assign = require(script.Parent.assign)\nlocal None = require(script.Parent.None)\nlocal Ref = require(script.Parent.PropMarkers.Ref)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal excludeRef = {\n\t[Ref] = None,\n}\n\n--[[\n\tAllows forwarding of refs to underlying host components. Accepts a render\n\tcallback which accepts props and a ref, and returns an element.\n]]\nlocal function forwardRef(render)\n\tif config.typeChecks then\n\t\tassert(typeof(render) == "function", "Expected arg #1 to be a function")\n\tend\n\n\treturn function(props)\n\t\tlocal ref = props[Ref]\n\t\tlocal propsWithoutRef = assign({}, props, excludeRef)\n\n\t\treturn render(propsWithoutRef, ref)\n\tend\nend\n\nreturn forwardRef\n'
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "getDefaultInstanceProperty",
                            Source = "--[[\n\tAttempts to get the default value of a given property on a Roblox instance.\n\n\tThis is used by the reconciler in cases where a prop was previously set on a\n\tprimitive component, but is no longer present in a component's new props.\n\n\tEventually, Roblox might provide a nicer API to query the default property\n\tof an object without constructing an instance of it.\n]]\n\nlocal Symbol = require(script.Parent.Symbol)\n\nlocal Nil = Symbol.named(\"Nil\")\nlocal _cachedPropertyValues = {}\n\nlocal function getDefaultInstanceProperty(className, propertyName)\n\tlocal classCache = _cachedPropertyValues[className]\n\n\tif classCache then\n\t\tlocal propValue = classCache[propertyName]\n\n\t\t-- We have to use a marker here, because Lua doesn't distinguish\n\t\t-- between 'nil' and 'not in a table'\n\t\tif propValue == Nil then\n\t\t\treturn true, nil\n\t\tend\n\n\t\tif propValue ~= nil then\n\t\t\treturn true, propValue\n\t\tend\n\telse\n\t\tclassCache = {}\n\t\t_cachedPropertyValues[className] = classCache\n\tend\n\n\tlocal created = Instance.new(className)\n\tlocal ok, defaultValue = pcall(function()\n\t\treturn created[propertyName]\n\tend)\n\n\tcreated:Destroy()\n\n\tif ok then\n\t\tif defaultValue == nil then\n\t\t\tclassCache[propertyName] = Nil\n\t\telse\n\t\t\tclassCache[propertyName] = defaultValue\n\t\tend\n\tend\n\n\treturn ok, defaultValue\nend\n\nreturn getDefaultInstanceProperty\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "internalAssert",
                            Source = 'local function internalAssert(condition, message)\n\tif not condition then\n\t\terror(message .. " (This is probably a bug in Roact!)", 3)\n\tend\nend\n\nreturn internalAssert\n'
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "invalidSetStateMessages",
                            Source = "--[[\n\tThese messages are used by Component to help users diagnose when they're\n\tcalling setState in inappropriate places.\n\n\tThe indentation may seem odd, but it's necessary to avoid introducing extra\n\twhitespace into the error messages themselves.\n]]\nlocal ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)\n\nlocal invalidSetStateMessages = {}\n\ninvalidSetStateMessages[ComponentLifecyclePhase.WillUpdate] = [[\nsetState cannot be used in the willUpdate lifecycle method.\nConsider using the didUpdate method instead, or using getDerivedStateFromProps.\n\nCheck the definition of willUpdate in the component %q.]]\n\ninvalidSetStateMessages[ComponentLifecyclePhase.ShouldUpdate] = [[\nsetState cannot be used in the shouldUpdate lifecycle method.\nshouldUpdate must be a pure function that only depends on props and state.\n\nCheck the definition of shouldUpdate in the component %q.]]\n\ninvalidSetStateMessages[ComponentLifecyclePhase.Render] = [[\nsetState cannot be used in the render method.\nrender must be a pure function that only depends on props and state.\n\nCheck the definition of render in the component %q.]]\n\ninvalidSetStateMessages[\"default\"] = [[\nsetState can not be used in the current situation, because Roact doesn't know\nwhich part of the lifecycle this component is in.\n\nThis is a bug in Roact.\nIt was triggered by the component %q.\n]]\n\nreturn invalidSetStateMessages\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "oneChild",
                            Source = '--[[\n\tRetrieves at most one child from the children passed to a component.\n\n\tIf passed nil or an empty table, will return nil.\n\n\tThrows an error if passed more than one child.\n]]\nlocal function oneChild(children)\n\tif not children then\n\t\treturn nil\n\tend\n\n\tlocal key, child = next(children)\n\n\tif not child then\n\t\treturn nil\n\tend\n\n\tlocal after = next(children, key)\n\n\tif after then\n\t\terror("Expected at most child, had more than one child.", 2)\n\tend\n\n\treturn child\nend\n\nreturn oneChild\n'
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "Type",
                            Source = '--[[\n\tContains markers for annotating objects with types.\n\n\tTo set the type of an object, use `Type` as a key and the actual marker as\n\tthe value:\n\n\t\tlocal foo = {\n\t\t\t[Type] = Type.Foo,\n\t\t}\n]]\n\nlocal Symbol = require(script.Parent.Symbol)\nlocal strict = require(script.Parent.strict)\n\nlocal Type = newproxy(true)\n\nlocal TypeInternal = {}\n\nlocal function addType(name)\n\tTypeInternal[name] = Symbol.named("Roact" .. name)\nend\n\naddType("Binding")\naddType("Element")\naddType("HostChangeEvent")\naddType("HostEvent")\naddType("StatefulComponentClass")\naddType("StatefulComponentInstance")\naddType("VirtualNode")\naddType("VirtualTree")\n\nfunction TypeInternal.of(value)\n\tif typeof(value) ~= "table" then\n\t\treturn nil\n\tend\n\n\treturn value[Type]\nend\n\ngetmetatable(Type).__index = TypeInternal\n\ngetmetatable(Type).__tostring = function()\n\treturn "RoactType"\nend\n\nstrict(TypeInternal, "Type")\n\nreturn Type\n'
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "strict",
                            Source = "--!strict\nlocal function strict(t: { [any]: any }, name: string?)\n\t-- FIXME Luau: Need to define a new variable since reassigning `name = ...`\n\t-- doesn't narrow the type\n\tlocal newName = name or tostring(t)\n\n\treturn setmetatable(t, {\n\t\t__index = function(_self, key)\n\t\t\tlocal message = (\"%q (%s) is not a valid member of %s\"):format(tostring(key), typeof(key), newName)\n\n\t\t\terror(message, 2)\n\t\tend,\n\n\t\t__newindex = function(_self, key, _value)\n\t\t\tlocal message = (\"%q (%s) is not a valid member of %s\"):format(tostring(key), typeof(key), newName)\n\n\t\t\terror(message, 2)\n\t\tend,\n\t})\nend\n\nreturn strict\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "RobloxRenderer",
                            Source = '--[[\n\tRenderer that deals in terms of Roblox Instances. This is the most\n\twell-supported renderer after NoopRenderer and is currently the only\n\trenderer that does anything.\n]]\n\nlocal Binding = require(script.Parent.Binding)\nlocal Children = require(script.Parent.PropMarkers.Children)\nlocal ElementKind = require(script.Parent.ElementKind)\nlocal SingleEventManager = require(script.Parent.SingleEventManager)\nlocal getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)\nlocal Ref = require(script.Parent.PropMarkers.Ref)\nlocal Type = require(script.Parent.Type)\nlocal internalAssert = require(script.Parent.internalAssert)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal applyPropsError = [[\nError applying props:\n\t%s\nIn element:\n%s\n]]\n\nlocal updatePropsError = [[\nError updating props:\n\t%s\nIn element:\n%s\n]]\n\nlocal function identity(...)\n\treturn ...\nend\n\nlocal function applyRef(ref, newHostObject)\n\tif ref == nil then\n\t\treturn\n\tend\n\n\tif typeof(ref) == "function" then\n\t\tref(newHostObject)\n\telseif Type.of(ref) == Type.Binding then\n\t\tBinding.update(ref, newHostObject)\n\telse\n\t\t-- TODO (#197): Better error message\n\t\terror(("Invalid ref: Expected type Binding but got %s"):format(typeof(ref)))\n\tend\nend\n\nlocal function setRobloxInstanceProperty(hostObject, key, newValue)\n\tif newValue == nil then\n\t\tlocal hostClass = hostObject.ClassName\n\t\tlocal _, defaultValue = getDefaultInstanceProperty(hostClass, key)\n\t\tnewValue = defaultValue\n\tend\n\n\t-- Assign the new value to the object\n\thostObject[key] = newValue\n\n\treturn\nend\n\nlocal function removeBinding(virtualNode, key)\n\tlocal disconnect = virtualNode.bindings[key]\n\tdisconnect()\n\tvirtualNode.bindings[key] = nil\nend\n\nlocal function attachBinding(virtualNode, key, newBinding)\n\tlocal function updateBoundProperty(newValue)\n\t\tlocal success, errorMessage = xpcall(function()\n\t\t\tsetRobloxInstanceProperty(virtualNode.hostObject, key, newValue)\n\t\tend, identity)\n\n\t\tif not success then\n\t\t\tlocal source = virtualNode.currentElement.source\n\n\t\t\tif source == nil then\n\t\t\t\tsource = "<enable element tracebacks>"\n\t\t\tend\n\n\t\t\tlocal fullMessage = updatePropsError:format(errorMessage, source)\n\t\t\terror(fullMessage, 0)\n\t\tend\n\tend\n\n\tif virtualNode.bindings == nil then\n\t\tvirtualNode.bindings = {}\n\tend\n\n\tvirtualNode.bindings[key] = Binding.subscribe(newBinding, updateBoundProperty)\n\n\tupdateBoundProperty(newBinding:getValue())\nend\n\nlocal function detachAllBindings(virtualNode)\n\tif virtualNode.bindings ~= nil then\n\t\tfor _, disconnect in pairs(virtualNode.bindings) do\n\t\t\tdisconnect()\n\t\tend\n\t\tvirtualNode.bindings = nil\n\tend\nend\n\nlocal function applyProp(virtualNode, key, newValue, oldValue)\n\tif newValue == oldValue then\n\t\treturn\n\tend\n\n\tif key == Ref or key == Children then\n\t\t-- Refs and children are handled in a separate pass\n\t\treturn\n\tend\n\n\tlocal internalKeyType = Type.of(key)\n\n\tif internalKeyType == Type.HostEvent or internalKeyType == Type.HostChangeEvent then\n\t\tif virtualNode.eventManager == nil then\n\t\t\tvirtualNode.eventManager = SingleEventManager.new(virtualNode.hostObject)\n\t\tend\n\n\t\tlocal eventName = key.name\n\n\t\tif internalKeyType == Type.HostChangeEvent then\n\t\t\tvirtualNode.eventManager:connectPropertyChange(eventName, newValue)\n\t\telse\n\t\t\tvirtualNode.eventManager:connectEvent(eventName, newValue)\n\t\tend\n\n\t\treturn\n\tend\n\n\tlocal newIsBinding = Type.of(newValue) == Type.Binding\n\tlocal oldIsBinding = Type.of(oldValue) == Type.Binding\n\n\tif oldIsBinding then\n\t\tremoveBinding(virtualNode, key)\n\tend\n\n\tif newIsBinding then\n\t\tattachBinding(virtualNode, key, newValue)\n\telse\n\t\tsetRobloxInstanceProperty(virtualNode.hostObject, key, newValue)\n\tend\nend\n\nlocal function applyProps(virtualNode, props)\n\tfor propKey, value in pairs(props) do\n\t\tapplyProp(virtualNode, propKey, value, nil)\n\tend\nend\n\nlocal function updateProps(virtualNode, oldProps, newProps)\n\t-- Apply props that were added or updated\n\tfor propKey, newValue in pairs(newProps) do\n\t\tlocal oldValue = oldProps[propKey]\n\n\t\tapplyProp(virtualNode, propKey, newValue, oldValue)\n\tend\n\n\t-- Clean up props that were removed\n\tfor propKey, oldValue in pairs(oldProps) do\n\t\tlocal newValue = newProps[propKey]\n\n\t\tif newValue == nil then\n\t\t\tapplyProp(virtualNode, propKey, nil, oldValue)\n\t\tend\n\tend\nend\n\nlocal RobloxRenderer = {}\n\nfunction RobloxRenderer.isHostObject(target)\n\treturn typeof(target) == "Instance"\nend\n\nfunction RobloxRenderer.mountHostNode(reconciler, virtualNode)\n\tlocal element = virtualNode.currentElement\n\tlocal hostParent = virtualNode.hostParent\n\tlocal hostKey = virtualNode.hostKey\n\n\tif config.internalTypeChecks then\n\t\tinternalAssert(ElementKind.of(element) == ElementKind.Host, "Element at given node is not a host Element")\n\tend\n\tif config.typeChecks then\n\t\tassert(element.props.Name == nil, "Name can not be specified as a prop to a host component in Roact.")\n\t\tassert(element.props.Parent == nil, "Parent can not be specified as a prop to a host component in Roact.")\n\tend\n\n\tlocal instance = Instance.new(element.component)\n\tvirtualNode.hostObject = instance\n\n\tlocal success, errorMessage = xpcall(function()\n\t\tapplyProps(virtualNode, element.props)\n\tend, identity)\n\n\tif not success then\n\t\tlocal source = element.source\n\n\t\tif source == nil then\n\t\t\tsource = "<enable element tracebacks>"\n\t\tend\n\n\t\tlocal fullMessage = applyPropsError:format(errorMessage, source)\n\t\terror(fullMessage, 0)\n\tend\n\n\tinstance.Name = tostring(hostKey)\n\n\tlocal children = element.props[Children]\n\n\tif children ~= nil then\n\t\treconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)\n\tend\n\n\tinstance.Parent = hostParent\n\tvirtualNode.hostObject = instance\n\n\tapplyRef(element.props[Ref], instance)\n\n\tif virtualNode.eventManager ~= nil then\n\t\tvirtualNode.eventManager:resume()\n\tend\nend\n\nfunction RobloxRenderer.unmountHostNode(reconciler, virtualNode)\n\tlocal element = virtualNode.currentElement\n\n\tapplyRef(element.props[Ref], nil)\n\n\tfor _, childNode in pairs(virtualNode.children) do\n\t\treconciler.unmountVirtualNode(childNode)\n\tend\n\n\tdetachAllBindings(virtualNode)\n\n\tvirtualNode.hostObject:Destroy()\nend\n\nfunction RobloxRenderer.updateHostNode(reconciler, virtualNode, newElement)\n\tlocal oldProps = virtualNode.currentElement.props\n\tlocal newProps = newElement.props\n\n\tif virtualNode.eventManager ~= nil then\n\t\tvirtualNode.eventManager:suspend()\n\tend\n\n\t-- If refs changed, detach the old ref and attach the new one\n\tif oldProps[Ref] ~= newProps[Ref] then\n\t\tapplyRef(oldProps[Ref], nil)\n\t\tapplyRef(newProps[Ref], virtualNode.hostObject)\n\tend\n\n\tlocal success, errorMessage = xpcall(function()\n\t\tupdateProps(virtualNode, oldProps, newProps)\n\tend, identity)\n\n\tif not success then\n\t\tlocal source = newElement.source\n\n\t\tif source == nil then\n\t\t\tsource = "<enable element tracebacks>"\n\t\tend\n\n\t\tlocal fullMessage = updatePropsError:format(errorMessage, source)\n\t\terror(fullMessage, 0)\n\tend\n\n\tlocal children = newElement.props[Children]\n\tif children ~= nil or oldProps[Children] ~= nil then\n\t\treconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)\n\tend\n\n\tif virtualNode.eventManager ~= nil then\n\t\tvirtualNode.eventManager:resume()\n\tend\n\n\treturn virtualNode\nend\n\nreturn RobloxRenderer\n'
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "Symbol",
                            Source = "--!strict\n--[[\n\tA 'Symbol' is an opaque marker type.\n\n\tSymbols have the type 'userdata', but when printed to the console, the name\n\tof the symbol is shown.\n]]\n\nlocal Symbol = {}\n\n--[[\n\tCreates a Symbol with the given name.\n\n\tWhen printed or coerced to a string, the symbol will turn into the string\n\tgiven as its name.\n]]\nfunction Symbol.named(name)\n\tassert(type(name) == \"string\", \"Symbols must be created using a string name!\")\n\n\tlocal self = newproxy(true)\n\n\tlocal wrappedName = (\"Symbol(%s)\"):format(name)\n\n\tgetmetatable(self).__tostring = function()\n\t\treturn wrappedName\n\tend\n\n\treturn self\nend\n\nreturn Symbol\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "SingleEventManager",
                            Source = "--[[\n\tA manager for a single host virtual node's connected events.\n]]\n\nlocal Logging = require(script.Parent.Logging)\n\nlocal CHANGE_PREFIX = \"Change.\"\n\nlocal EventStatus = {\n\t-- No events are processed at all; they're silently discarded\n\tDisabled = \"Disabled\",\n\n\t-- Events are stored in a queue; listeners are invoked when the manager is resumed\n\tSuspended = \"Suspended\",\n\n\t-- Event listeners are invoked as the events fire\n\tEnabled = \"Enabled\",\n}\n\nlocal SingleEventManager = {}\nSingleEventManager.__index = SingleEventManager\n\nfunction SingleEventManager.new(instance)\n\tlocal self = setmetatable({\n\t\t-- The queue of suspended events\n\t\t_suspendedEventQueue = {},\n\n\t\t-- All the event connections being managed\n\t\t-- Events are indexed by a string key\n\t\t_connections = {},\n\n\t\t-- All the listeners being managed\n\t\t-- These are stored distinctly from the connections\n\t\t-- Connections can have their listeners replaced at runtime\n\t\t_listeners = {},\n\n\t\t-- The suspension status of the manager\n\t\t-- Managers start disabled and are \"resumed\" after the initial render\n\t\t_status = EventStatus.Disabled,\n\n\t\t-- If true, the manager is processing queued events right now.\n\t\t_isResuming = false,\n\n\t\t-- The Roblox instance the manager is managing\n\t\t_instance = instance,\n\t}, SingleEventManager)\n\n\treturn self\nend\n\nfunction SingleEventManager:connectEvent(key, listener)\n\tself:_connect(key, self._instance[key], listener)\nend\n\nfunction SingleEventManager:connectPropertyChange(key, listener)\n\tlocal success, event = pcall(function()\n\t\treturn self._instance:GetPropertyChangedSignal(key)\n\tend)\n\n\tif not success then\n\t\terror((\"Cannot get changed signal on property %q: %s\"):format(tostring(key), event), 0)\n\tend\n\n\tself:_connect(CHANGE_PREFIX .. key, event, listener)\nend\n\nfunction SingleEventManager:_connect(eventKey, event, listener)\n\t-- If the listener doesn't exist we can just disconnect the existing connection\n\tif listener == nil then\n\t\tif self._connections[eventKey] ~= nil then\n\t\t\tself._connections[eventKey]:Disconnect()\n\t\t\tself._connections[eventKey] = nil\n\t\tend\n\n\t\tself._listeners[eventKey] = nil\n\telse\n\t\tif self._connections[eventKey] == nil then\n\t\t\tself._connections[eventKey] = event:Connect(function(...)\n\t\t\t\tif self._status == EventStatus.Enabled then\n\t\t\t\t\tself._listeners[eventKey](self._instance, ...)\n\t\t\t\telseif self._status == EventStatus.Suspended then\n\t\t\t\t\t-- Store this event invocation to be fired when resume is\n\t\t\t\t\t-- called.\n\n\t\t\t\t\tlocal argumentCount = select(\"#\", ...)\n\t\t\t\t\ttable.insert(self._suspendedEventQueue, { eventKey, argumentCount, ... })\n\t\t\t\tend\n\t\t\tend)\n\t\tend\n\n\t\tself._listeners[eventKey] = listener\n\tend\nend\n\nfunction SingleEventManager:suspend()\n\tself._status = EventStatus.Suspended\nend\n\nfunction SingleEventManager:resume()\n\t-- If we're already resuming events for this instance, trying to resume\n\t-- again would cause a disaster.\n\tif self._isResuming then\n\t\treturn\n\tend\n\n\tself._isResuming = true\n\n\tlocal index = 1\n\n\t-- More events might be added to the queue when evaluating events, so we\n\t-- need to be careful in order to preserve correct evaluation order.\n\twhile index <= #self._suspendedEventQueue do\n\t\tlocal eventInvocation = self._suspendedEventQueue[index]\n\t\tlocal listener = self._listeners[eventInvocation[1]]\n\t\tlocal argumentCount = eventInvocation[2]\n\n\t\t-- The event might have been disconnected since suspension started; in\n\t\t-- this case, we drop the event.\n\t\tif listener ~= nil then\n\t\t\t-- Wrap the listener in a coroutine to catch errors and handle\n\t\t\t-- yielding correctly.\n\t\t\tlocal listenerCo = coroutine.create(listener)\n\t\t\tlocal success, result = coroutine.resume(\n\t\t\t\tlistenerCo,\n\t\t\t\tself._instance,\n\t\t\t\tunpack(eventInvocation, 3, 2 + argumentCount)\n\t\t\t)\n\n\t\t\t-- If the listener threw an error, we log it as a warning, since\n\t\t\t-- there's no way to write error text in Roblox Lua without killing\n\t\t\t-- our thread!\n\t\t\tif not success then\n\t\t\t\tLogging.warn(\"%s\", result)\n\t\t\tend\n\t\tend\n\n\t\tindex = index + 1\n\tend\n\n\tself._isResuming = false\n\tself._status = EventStatus.Enabled\n\tself._suspendedEventQueue = {}\nend\n\nreturn SingleEventManager\n"
                          }
                        } },
                      Properties = {
                        ClassName = "ModuleScript",
                        Name = "src",
                        Source = "--~strict\n--[[\n\tPackages up the internals of Roact and exposes a public API for it.\n]]\n\nlocal GlobalConfig = require(script.GlobalConfig)\nlocal createReconciler = require(script.createReconciler)\nlocal createReconcilerCompat = require(script.createReconcilerCompat)\nlocal RobloxRenderer = require(script.RobloxRenderer)\nlocal strict = require(script.strict)\nlocal Binding = require(script.Binding)\n\nlocal robloxReconciler = createReconciler(RobloxRenderer)\nlocal reconcilerCompat = createReconcilerCompat(robloxReconciler)\n\nlocal Roact = strict({\n\tComponent = require(script.Component),\n\tcreateElement = require(script.createElement),\n\tcreateFragment = require(script.createFragment),\n\toneChild = require(script.oneChild),\n\tPureComponent = require(script.PureComponent),\n\tNone = require(script.None),\n\tPortal = require(script.Portal),\n\tcreateRef = require(script.createRef),\n\tforwardRef = require(script.forwardRef),\n\tcreateBinding = Binding.create,\n\tjoinBindings = Binding.join,\n\tcreateContext = require(script.createContext),\n\n\tChange = require(script.PropMarkers.Change),\n\tChildren = require(script.PropMarkers.Children),\n\tEvent = require(script.PropMarkers.Event),\n\tRef = require(script.PropMarkers.Ref),\n\n\tmount = robloxReconciler.mountVirtualTree,\n\tunmount = robloxReconciler.unmountVirtualTree,\n\tupdate = robloxReconciler.updateVirtualTree,\n\n\treify = reconcilerCompat.reify,\n\tteardown = reconcilerCompat.teardown,\n\treconcile = reconcilerCompat.reconcile,\n\n\tsetGlobalConfig = GlobalConfig.set,\n\n\t-- APIs that may change in the future without warning\n\tUNSTABLE = {},\n})\n\nreturn Roact\n"
                      }
                    } },
                  Properties = {
                    ClassName = "Folder",
                    Name = "roact"
                  }
                }, {
                  Children = { {
                      Children = { {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "NoYield",
                            Source = '--[[\n\tCalls a function and throws an error if it attempts to yield.\n\tPass any number of arguments to the function after the callback.\n\tThis function supports multiple return; all results returned from the\n\tgiven function will be returned.\n\thttps://github.com/Roblox/rodux/blob/master/src/NoYield.lua\n]]\n\nlocal function resultHandler(co: thread, ok: boolean, ...)\n\tif not ok then\n\t\tlocal err = (...)\n\t\tif typeof(err) == "string" then\n\t\t\terror(debug.traceback(co, err), 2)\n\t\telse\n\t\t\t-- If the error is not of type string, just assume it has some\n\t\t\t-- meaningful information and rethrow it with a `tostring` so that\n\t\t\t-- top-level error handlers can process it\n\t\t\terror(tostring(err), 2)\n\t\tend\n\tend\n\n\tif coroutine.status(co) ~= "dead" then\n\t\terror(debug.traceback(co, "Attempted to yield inside useEffect!"), 2)\n\tend\n\n\treturn ...\nend\n\nlocal function NoYield(callback, ...)\n\tlocal co = coroutine.create(callback)\n\n\treturn resultHandler(co, coroutine.resume(co, ...))\nend\n\nreturn NoYield\n'
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "Roact",
                            Source = 'local modules = script:FindFirstAncestor("node_modules")\n\nif modules:FindFirstChild("roact") then\n\treturn require(modules.roact.src)\nelseif modules:FindFirstChild("@rbxts") then\n\treturn require(modules["@rbxts"].roact.src)\nelseif script.Parent.Parent:FindFirstChild("Roact") then\n\treturn require(script.Parent.Parent.Roact)\nelse\n\terror("Could not find Roact or @rbxts/roact in the parent hierarchy.")\nend\n'
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "hoc",
                            Source = 'local Roact = require(script.Parent.Roact)\nlocal hooks = require(script.Parent.hooks)\nlocal prepareToUseHooks = hooks.prepareToUseHooks\nlocal finishHooks = hooks.finishHooks\nlocal commitHookEffectListUpdate = hooks.commitHookEffectListUpdate\nlocal commitHookEffectListUnmount = hooks.commitHookEffectListUnmount\n\nlocal function withHooksImpl(Component, Class, api)\n\tlocal componentName = debug.info(Component, "n") or "Component"\n\tif componentName == "" then\n\t\tcomponentName = "Component"\n\tend\n\n\tlocal Proxy = Class:extend(componentName .. " (roact-hooked)")\n\n\tProxy._name = componentName\n\n\tfunction Proxy:render()\n\t\tprepareToUseHooks(self)\n\t\tlocal children = Component(self.props)\n\t\tfinishHooks()\n\t\treturn children\n\tend\n\n\tfunction Proxy:didMount()\n\t\tcommitHookEffectListUpdate(self)\n\tend\n\n\tfunction Proxy:didUpdate()\n\t\tcommitHookEffectListUpdate(self)\n\tend\n\n\tfunction Proxy:willUnmount()\n\t\tcommitHookEffectListUnmount(self)\n\tend\n\n\tif api and type(api) == "table" then\n\t\tfor k, v in pairs(api) do\n\t\t\tProxy[k] = v\n\t\tend\n\tend\n\n\treturn Proxy\nend\n\nlocal function withHooks(Component, api)\n\treturn withHooksImpl(Component, Roact.Component, api)\nend\n\nlocal function withHooksPure(Component, api)\n\treturn withHooksImpl(Component, Roact.PureComponent, api)\nend\n\nreturn {\n\twithHooks = withHooks,\n\twithHooksPure = withHooksPure,\n}\n'
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "hooks",
                            Source = "-- https://github.com/facebook/react/blob/main/packages/react-dom/src/server/ReactPartialRendererHooks.js\n-- https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js\n\nlocal Roact = require(script.Parent.Roact)\nlocal NoYield = require(script.Parent.NoYield)\n\nlocal currentlyRenderingComponent\nlocal hookCount = 0\nlocal workInProgressHook\n\nlocal isReRender\n\n-- Used in wrapCreateElement to determine whether this component will use hooks\nlocal didUseHooks = false\nlocal forceEarlyExit = false\n\nlocal function finishHookTest()\n\tforceEarlyExit = false\n\treturn didUseHooks\nend\n\nlocal function prepareHookTest()\n\tdidUseHooks = false\n\tforceEarlyExit = true\nend\n\nlocal function finishHooks()\n\tcurrentlyRenderingComponent = nil\n\thookCount = 0\n\tworkInProgressHook = nil\nend\n\nlocal function prepareToUseHooks(componentIdentity)\n\tif workInProgressHook ~= nil then\n\t\tlocal prev = currentlyRenderingComponent._name\n\t\tlocal current = componentIdentity._name\n\t\twarn(\n\t\t\t`The component '{prev}' did not finish rendering before '{current}' started rendering. Did the former yield or fail to run?`\n\t\t)\n\t\tfinishHooks()\n\tend\n\n\tcurrentlyRenderingComponent = componentIdentity\nend\n\nlocal function resolveCurrentlyRenderingComponent()\n\tdidUseHooks = true\n\n\tif forceEarlyExit or not currentlyRenderingComponent then\n\t\terror(\n\t\t\t\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n\"\n\t\t\t\t.. \"1. You might be using hooks outside of the withHooks() HOC\\n\"\n\t\t\t\t.. \"2. You might be breaking the Rules of Hooks\\n\"\n\t\t\t\t.. \"3. A hooked component may have yielded or thrown an error\\n\"\n\t\t)\n\tend\n\n\treturn currentlyRenderingComponent\nend\n\nlocal function areHookInputsEqual(nextDeps, prevDeps)\n\tif not prevDeps then\n\t\treturn false\n\tend\n\n\tif type(nextDeps) ~= type(prevDeps) then\n\t\treturn false\n\tend\n\n\tif type(nextDeps) == \"table\" then\n\t\tfor key, value in pairs(nextDeps) do\n\t\t\tif prevDeps[key] ~= value then\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\n\t\tfor key, value in pairs(prevDeps) do\n\t\t\tif nextDeps[key] ~= value then\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\n\t\treturn true\n\tend\n\n\treturn nextDeps == prevDeps\nend\n\nlocal function createHook()\n\treturn {\n\t\tmemoizedState = nil,\n\t\tnext = nil,\n\t\tindex = hookCount,\n\t}\nend\n\nlocal function createWorkInProgressHook()\n\thookCount += 1\n\n\tif not workInProgressHook then\n\t\t-- This is the first hook in the list\n\t\tif not currentlyRenderingComponent.firstHook then\n\t\t\t-- The component is being mounted. Create a new hook.\n\t\t\tisReRender = false\n\n\t\t\tlocal hook = createHook()\n\t\t\tcurrentlyRenderingComponent.firstHook = hook\n\t\t\tworkInProgressHook = hook\n\t\telse\n\t\t\t-- The component is being re-rendered. Reuse the first hook.\n\t\t\tisReRender = true\n\t\t\tworkInProgressHook = currentlyRenderingComponent.firstHook\n\t\tend\n\telse\n\t\tif not workInProgressHook.next then\n\t\t\tisReRender = false\n\n\t\t\t-- Append to the end of the list\n\t\t\tlocal hook = createHook()\n\t\t\tworkInProgressHook.next = hook\n\t\t\tworkInProgressHook = hook\n\t\telse\n\t\t\tisReRender = true\n\t\t\tworkInProgressHook = workInProgressHook.next\n\t\tend\n\tend\n\n\treturn workInProgressHook\nend\n\nlocal function commitHookEffectListUpdate(componentIdentity)\n\tlocal lastEffect = componentIdentity.lastEffect\n\n\tif not lastEffect then\n\t\treturn\n\tend\n\n\tlocal firstEffect = lastEffect.next\n\tlocal effect = firstEffect\n\n\trepeat\n\t\tif effect.prevDeps and areHookInputsEqual(effect.deps, effect.prevDeps) then\n\t\t\t-- Nothing changed\n\t\t\teffect = effect.next\n\t\t\tcontinue\n\t\tend\n\n\t\t-- Clear\n\t\tlocal destroy = effect.destroy\n\t\teffect.destroy = nil\n\n\t\tif type(destroy) == \"function\" then\n\t\t\tNoYield(destroy)\n\t\tend\n\n\t\t-- Update\n\t\tNoYield(function()\n\t\t\teffect.destroy = effect.create()\n\t\tend)\n\n\t\teffect = effect.next\n\tuntil effect == firstEffect\nend\n\nlocal function commitHookEffectListUnmount(componentIdentity)\n\tlocal lastEffect = componentIdentity.lastEffect\n\n\tif not lastEffect then\n\t\treturn\n\tend\n\n\tlocal firstEffect = lastEffect.next\n\tlocal effect = firstEffect\n\n\trepeat\n\t\t-- Clear\n\t\tlocal destroy = effect.destroy\n\t\teffect.destroy = nil\n\n\t\tif type(destroy) == \"function\" then\n\t\t\tNoYield(destroy)\n\t\tend\n\n\t\teffect = effect.next\n\tuntil effect == firstEffect\nend\n\nlocal function pushEffect(create, destroy, deps)\n\tresolveCurrentlyRenderingComponent()\n\n\tlocal effect = {\n\t\tcreate = create,\n\t\tdestroy = destroy,\n\t\tdeps = deps,\n\t\tprevDeps = nil,\n\t\tnext = nil,\n\t}\n\n\tlocal lastEffect = currentlyRenderingComponent.lastEffect\n\n\tif lastEffect then\n\t\tlocal firstEffect = lastEffect.next\n\t\tlastEffect.next = effect\n\t\teffect.next = firstEffect\n\t\tcurrentlyRenderingComponent.lastEffect = effect\n\telse\n\t\teffect.next = effect\n\t\tcurrentlyRenderingComponent.lastEffect = effect\n\tend\n\n\treturn effect\nend\n\nlocal function useEffect(create, deps)\n\tresolveCurrentlyRenderingComponent()\n\n\tlocal hook = createWorkInProgressHook()\n\n\tif not isReRender then\n\t\thook.memoizedState = pushEffect(create, nil, deps)\n\telse\n\t\thook.memoizedState.prevDeps = hook.memoizedState.deps\n\t\thook.memoizedState.deps = deps\n\t\thook.memoizedState.create = create\n\tend\nend\n\nlocal function basicStateReducer(state, action)\n\tif type(action) == \"function\" then\n\t\treturn action(state)\n\telse\n\t\treturn action\n\tend\nend\n\nlocal function useReducer(reducer, initialArg, init)\n\tlocal component = resolveCurrentlyRenderingComponent()\n\tlocal hook = createWorkInProgressHook()\n\n\t-- Mount\n\tif not isReRender then\n\t\tlocal initialState\n\n\t\tif reducer == basicStateReducer then\n\t\t\t-- Special case for `useState`.\n\t\t\tif type(initialArg) == \"function\" then\n\t\t\t\tinitialState = initialArg()\n\t\t\telse\n\t\t\t\tinitialState = initialArg\n\t\t\tend\n\t\telse\n\t\t\tif init then\n\t\t\t\tinitialState = init(initialArg)\n\t\t\telse\n\t\t\t\tinitialState = initialArg\n\t\t\tend\n\t\tend\n\n\t\tlocal function dispatch(action)\n\t\t\tlocal nextState = reducer(hook.memoizedState.state, action)\n\n\t\t\tif nextState == hook.memoizedState.state then\n\t\t\t\treturn\n\t\t\tend\n\n\t\t\thook.memoizedState.state = nextState\n\n\t\t\tcomponent:setState({\n\t\t\t\t[hook.index] = nextState,\n\t\t\t})\n\t\tend\n\n\t\thook.memoizedState = {\n\t\t\tdispatch = dispatch,\n\t\t\tstate = initialState,\n\t\t}\n\tend\n\n\treturn hook.memoizedState.state, hook.memoizedState.dispatch\nend\n\nlocal function useState(initialState)\n\t-- Use useReducer's special case for `useState`.\n\treturn useReducer(basicStateReducer, initialState)\nend\n\nlocal function useMemo(create, deps)\n\tresolveCurrentlyRenderingComponent()\n\n\tlocal hook = createWorkInProgressHook()\n\tlocal prevState = hook.memoizedState\n\n\tif prevState ~= nil and deps ~= nil and areHookInputsEqual(deps, prevState.deps) then\n\t\treturn prevState.value\n\tend\n\n\tlocal value = create()\n\thook.memoizedState = { value = value, deps = deps }\n\n\treturn value\nend\n\nlocal function useCallback(callback, deps)\n\treturn useMemo(function()\n\t\treturn callback\n\tend, deps)\nend\n\nlocal function useMutable(initialValue)\n\tresolveCurrentlyRenderingComponent()\n\n\tlocal hook = createWorkInProgressHook()\n\n\tif not isReRender then\n\t\thook.memoizedState = { current = initialValue }\n\tend\n\n\treturn hook.memoizedState\nend\n\nlocal function useRef()\n\tresolveCurrentlyRenderingComponent()\n\n\tlocal hook = createWorkInProgressHook()\n\n\tif not isReRender then\n\t\thook.memoizedState = Roact.createRef()\n\tend\n\n\treturn hook.memoizedState\nend\n\nlocal function useBinding(initialValue)\n\tresolveCurrentlyRenderingComponent()\n\n\tlocal hook = createWorkInProgressHook()\n\n\tif not isReRender then\n\t\tlocal binding, setValue = Roact.createBinding(initialValue)\n\t\thook.memoizedState = { binding = binding, setValue = setValue }\n\tend\n\n\treturn hook.memoizedState.binding, hook.memoizedState.setValue\nend\n\nlocal function useContext(context)\n\tresolveCurrentlyRenderingComponent()\n\n\tlocal hook = createWorkInProgressHook()\n\n\tif not isReRender then\n\t\t-- Using https://github.com/Kampfkarren/roact-hooks/pull/38\n\t\tlocal memoizedState = {\n\t\t\tfakeConsumer = setmetatable({}, {\n\t\t\t\t__index = currentlyRenderingComponent,\n\t\t\t}),\n\t\t\tinitialValue = nil,\n\t\t}\n\n\t\tlocal initialValue\n\n\t\tmemoizedState.fakeConsumer.props = {\n\t\t\trender = function(value)\n\t\t\t\tinitialValue = value\n\t\t\tend,\n\t\t}\n\n\t\t-- contextEntry is always nil here, so it will pass initialValue to render\n\t\tcontext.Consumer.render(memoizedState.fakeConsumer)\n\n\t\tmemoizedState.initialValue = initialValue\n\t\thook.memoizedState = memoizedState\n\tend\n\n\t-- Sets the context entry internally\n\tcontext.Consumer.init(hook.memoizedState.fakeConsumer)\n\n\tlocal contextEntry = hook.memoizedState.fakeConsumer.contextEntry\n\tlocal initialValue = hook.memoizedState.initialValue\n\n\tlocal value, setValue = useState(if contextEntry == nil then initialValue else contextEntry.value)\n\n\tuseEffect(function()\n\t\tif contextEntry == nil then\n\t\t\tif value ~= initialValue then\n\t\t\t\tsetValue(initialValue)\n\t\t\tend\n\t\t\treturn\n\t\tend\n\n\t\tif value ~= contextEntry.value then\n\t\t\tsetValue(contextEntry.value)\n\t\tend\n\n\t\treturn contextEntry.onUpdate:subscribe(setValue)\n\tend, { contextEntry })\n\n\treturn value\nend\n\nreturn {\n\t-- Hooks\n\tuseBinding = useBinding,\n\tuseCallback = useCallback,\n\tuseContext = useContext,\n\tuseEffect = useEffect,\n\tuseMemo = useMemo,\n\tuseMutable = useMutable,\n\tuseReducer = useReducer,\n\tuseRef = useRef,\n\tuseState = useState,\n\n\t-- Internal API\n\tprepareHookTest = prepareHookTest,\n\tfinishHookTest = finishHookTest,\n\tcommitHookEffectListUpdate = commitHookEffectListUpdate,\n\tcommitHookEffectListUnmount = commitHookEffectListUnmount,\n\tprepareToUseHooks = prepareToUseHooks,\n\tfinishHooks = finishHooks,\n}\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "pureComponent",
                            Source = "local pureComponents = {}\n\nlocal function markPureComponent(functionComponent)\n\tpureComponents[functionComponent] = true\n\treturn functionComponent\nend\n\nlocal function isPureComponent(functionComponent)\n\treturn pureComponents[functionComponent]\nend\n\nreturn {\n\tmarkPureComponent = markPureComponent,\n\tisPureComponent = isPureComponent,\n}\n"
                          }
                        }, {
                          Children = {},
                          Properties = {
                            ClassName = "ModuleScript",
                            Name = "withHookDetection",
                            Source = "local hoc = require(script.Parent.hoc)\nlocal hooks = require(script.Parent.hooks)\nlocal pureComponent = require(script.Parent.pureComponent)\n\nlocal proxyComponents = {}\nlocal statelessComponents = {}\nlocal modulesWithHookDetection = {}\n\nlocal function withHookDetection(Roact, options)\n\toptions = options or {}\n\n\tlocal moduleId = tostring(Roact)\n\tlocal createElement = Roact.createElement\n\n\tlocal forcePureComponent = if options.forcePureComponent ~= nil then options.forcePureComponent else false\n\tlocal debugMode = if options.debug ~= nil then options.debug else false\n\n\tif modulesWithHookDetection[moduleId] then\n\t\treturn\n\tend\n\n\tmodulesWithHookDetection[moduleId] = true\n\n\tfunction Roact.createElement(component, props, children)\n\t\tif type(component) ~= \"function\" or statelessComponents[component] then\n\t\t\treturn createElement(component, props, children)\n\t\tend\n\n\t\tif proxyComponents[component] then\n\t\t\t-- The proxy for this component has already been created\n\t\t\treturn createElement(proxyComponents[component], props, children)\n\t\tend\n\n\t\thooks.prepareHookTest()\n\n\t\tpcall(component, if props ~= nil then props else {})\n\n\t\tlocal didUseHooks = hooks.finishHookTest()\n\n\t\tif didUseHooks then\n\t\t\t-- If the component tried to use hooks, create a proxy component\n\t\t\tlocal proxyComponent\n\n\t\t\tif pureComponent.isPureComponent(component) or forcePureComponent then\n\t\t\t\tproxyComponent = hoc.withHooksPure(component)\n\t\t\telse\n\t\t\t\tproxyComponent = hoc.withHooks(component)\n\t\t\tend\n\n\t\t\tif debugMode then\n\t\t\t\tlocal render = proxyComponent.render\n\n\t\t\t\tfunction proxyComponent:render(...)\n\t\t\t\t\tdebug.profilebegin(self._name)\n\t\t\t\t\tlocal success, result = pcall(render, self, ...)\n\t\t\t\t\tdebug.profileend()\n\n\t\t\t\t\tif not success then\n\t\t\t\t\t\terror(result, 2)\n\t\t\t\t\tend\n\n\t\t\t\t\treturn result\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tproxyComponents[component] = proxyComponent\n\n\t\t\treturn createElement(proxyComponent, props, children)\n\t\telse\n\t\t\t-- Mark this component as stateless so we don't have to check it again\n\t\t\tstatelessComponents[component] = true\n\t\t\treturn createElement(component, props, children)\n\t\tend\n\tend\n\n\treturn Roact\nend\n\nreturn withHookDetection\n"
                          }
                        } },
                      Properties = {
                        ClassName = "ModuleScript",
                        Name = "src",
                        Source = "local hoc = require(script.hoc)\nlocal hooks = require(script.hooks)\nlocal withHookDetection = require(script.withHookDetection)\nlocal pureComponent = require(script.pureComponent)\n\nreturn {\n\t-- HOC\n\twithHooks = hoc.withHooks,\n\twithHooksPure = hoc.withHooksPure,\n\twithHookDetection = withHookDetection,\n\tmarkPureComponent = pureComponent.markPureComponent,\n\n\t-- Hooks\n\tuseBinding = hooks.useBinding,\n\tuseCallback = hooks.useCallback,\n\tuseContext = hooks.useContext,\n\tuseEffect = hooks.useEffect,\n\tuseMemo = hooks.useMemo,\n\tuseMutable = hooks.useMutable,\n\tuseReducer = hooks.useReducer,\n\tuseRef = hooks.useRef,\n\tuseState = hooks.useState,\n}\n"
                      }
                    } },
                  Properties = {
                    ClassName = "Folder",
                    Name = "roact-hooked"
                  }
                } },
              Properties = {
                ClassName = "Folder",
                Name = "@rbxts"
              }
            } },
          Properties = {
            ClassName = "Folder",
            Name = "node_modules"
          }
        } },
      Properties = {
        ClassName = "Folder",
        Name = "rbxts_include"
      }
    }, {
      Children = {},
      Properties = {
        ClassName = "ModuleScript",
        Name = "Teleport",
        Source = '-- Compiled with roblox-ts v2.3.0\nlocal TS = require(script.Parent:WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))\nlocal Roact = TS.import(script, script.Parent, "rbxts_include", "node_modules", "@rbxts", "roact", "src")\nlocal _roact_hooked = TS.import(script, script.Parent, "rbxts_include", "node_modules", "@rbxts", "roact-hooked", "src")\nlocal useEffect = _roact_hooked.useEffect\nlocal withHooks = _roact_hooked.withHooks\nlocal function PlayerLabel(props)\n\tlocal btnRef = Roact.createRef()\n\treturn Roact.createFragment({\n\t\t[tostring(props.UserId)] = Roact.createElement("Frame", {\n\t\t\tSize = UDim2.new(1, 0, 0, 25),\n\t\t\tBackgroundTransparency = 1,\n\t\t}, {\n\t\t\tRoact.createElement("TextButton", {\n\t\t\t\t[Roact.Ref] = btnRef,\n\t\t\t\tSize = UDim2.new(1, 0, 1, 0),\n\t\t\t\tBackgroundTransparency = 1,\n\t\t\t\tText = "",\n\t\t\t\tBorderSizePixel = 0,\n\t\t\t\tBackgroundColor3 = Color3.new(0, 0, 0),\n\t\t\t\tAutoButtonColor = false,\n\t\t\t\t[Roact.Event.MouseEnter] = function()\n\t\t\t\t\tgame:GetService("TweenService"):Create(btnRef:getValue(), TweenInfo.new(0.25), {\n\t\t\t\t\t\tBackgroundTransparency = 0.75,\n\t\t\t\t\t}):Play()\n\t\t\t\tend,\n\t\t\t\t[Roact.Event.MouseLeave] = function()\n\t\t\t\t\tgame:GetService("TweenService"):Create(btnRef:getValue(), TweenInfo.new(0.25), {\n\t\t\t\t\t\tBackgroundTransparency = 1,\n\t\t\t\t\t}):Play()\n\t\t\t\tend,\n\t\t\t\t[Roact.Event.MouseButton1Down] = function()\n\t\t\t\t\tlocal clkTween = game:GetService("TweenService"):Create(btnRef:getValue(), TweenInfo.new(0.075), {\n\t\t\t\t\t\tBackgroundColor3 = Color3.new(0.75, 0.75, 0.75),\n\t\t\t\t\t})\n\t\t\t\t\tclkTween:Play()\n\t\t\t\t\tclkTween.Completed:Connect(function()\n\t\t\t\t\t\tgame:GetService("TweenService"):Create(btnRef:getValue(), TweenInfo.new(0.075), {\n\t\t\t\t\t\t\tBackgroundColor3 = Color3.new(0, 0, 0),\n\t\t\t\t\t\t}):Play()\n\t\t\t\t\tend)\n\t\t\t\tend,\n\t\t\t\t[Roact.Event.MouseButton1Click] = function()\n\t\t\t\t\tlocal pivotLocation = (game:GetService("Players"):GetPlayerByUserId(props.UserId).Character:FindFirstChild("HumanoidRootPart")).CFrame\n\t\t\t\t\tlocal _result = game:GetService("Players").LocalPlayer.Character\n\t\t\t\t\tif _result ~= nil then\n\t\t\t\t\t\t_result:PivotTo(pivotLocation)\n\t\t\t\t\tend\n\t\t\t\tend,\n\t\t\t}, {\n\t\t\t\tRoact.createElement("UIListLayout", {\n\t\t\t\t\tFillDirection = Enum.FillDirection.Horizontal,\n\t\t\t\t\tHorizontalAlignment = Enum.HorizontalAlignment.Left,\n\t\t\t\t\tSortOrder = Enum.SortOrder.LayoutOrder,\n\t\t\t\t\tPadding = UDim.new(0, 5),\n\t\t\t\t}),\n\t\t\t\tRoact.createElement("TextLabel", {\n\t\t\t\t\tLayoutOrder = 2,\n\t\t\t\t\tBackgroundTransparency = 1,\n\t\t\t\t\tText = game:GetService("Players"):GetNameFromUserIdAsync(props.UserId),\n\t\t\t\t\tSize = UDim2.new(0, 0, 1, 0),\n\t\t\t\t\tAutomaticSize = Enum.AutomaticSize.X,\n\t\t\t\t\tFont = Enum.Font.ArialBold,\n\t\t\t\t\tTextSize = 14,\n\t\t\t\t\tTextColor3 = Color3.new(1, 1, 1),\n\t\t\t\t}),\n\t\t\t\tRoact.createElement("ImageLabel", {\n\t\t\t\t\tSize = UDim2.new(1, 0, 1, 0),\n\t\t\t\t\tSizeConstraint = Enum.SizeConstraint.RelativeYY,\n\t\t\t\t\tLayoutOrder = 1,\n\t\t\t\t\tImage = (game:GetService("Players"):GetUserThumbnailAsync(props.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size100x100)),\n\t\t\t\t}, {\n\t\t\t\t\tRoact.createElement("UICorner", {\n\t\t\t\t\t\tCornerRadius = UDim.new(1, 0),\n\t\t\t\t\t}),\n\t\t\t\t}),\n\t\t\t}),\n\t\t\tRoact.createElement("Frame", {\n\t\t\t\tPosition = UDim2.new(0, 0, 1, 0),\n\t\t\t\tSize = UDim2.new(1, 0, 0, 1),\n\t\t\t\tBackgroundColor3 = Color3.new(1, 1, 1),\n\t\t\t\tBorderSizePixel = 0,\n\t\t\t\tBackgroundTransparency = 0.5,\n\t\t\t}),\n\t\t}),\n\t})\nend\nlocal Window = withHooks(function(props)\n\tlocal sfRef = Roact.createRef()\n\tlocal btnRef = Roact.createRef()\n\tuseEffect(function()\n\t\tspawn(function()\n\t\t\tlocal scrollf = sfRef:getValue()\n\t\t\tfor _, plr in game:GetService("Players"):GetChildren() do\n\t\t\t\tRoact.mount(Roact.createElement(PlayerLabel, {\n\t\t\t\t\tUserId = plr.UserId,\n\t\t\t\t}), scrollf)\n\t\t\tend\n\t\t\tgame:GetService("Players").PlayerAdded:Connect(function(plr)\n\t\t\t\tRoact.mount(Roact.createElement(PlayerLabel, {\n\t\t\t\t\tUserId = plr.UserId,\n\t\t\t\t}), scrollf)\n\t\t\tend)\n\t\t\tgame:GetService("Players").PlayerRemoving:Connect(function(plr)\n\t\t\t\tscrollf:FindFirstChild(tostring(plr.UserId))\n\t\t\tend)\n\t\tend)\n\tend)\n\treturn Roact.createElement("Frame", {\n\t\tSize = UDim2.new(0.25 * 0.8, 0, 0.5 * 0.8, 0),\n\t\tPosition = UDim2.new(0, 0, 0.5, 0),\n\t\tAnchorPoint = Vector2.new(0, 0.5),\n\t\tSizeConstraint = Enum.SizeConstraint.RelativeYY,\n\t\tBackgroundTransparency = 1,\n\t\tBorderSizePixel = 0,\n\t}, {\n\t\tRoact.createElement("TextButton", {\n\t\t\t[Roact.Ref] = btnRef,\n\t\t\tZIndex = 2,\n\t\t\tPosition = UDim2.new(0, 2, 0, 0),\n\t\t\tAnchorPoint = Vector2.new(0, 0.5),\n\t\t\tSize = UDim2.new(0.15, 0, 0.15, 0),\n\t\t\tSizeConstraint = Enum.SizeConstraint.RelativeXX,\n\t\t\tText = "-",\n\t\t\tFont = Enum.Font.ArialBold,\n\t\t\tTextScaled = true,\n\t\t\tTextColor3 = Color3.new(1, 1, 1),\n\t\t\tBackgroundColor3 = Color3.new(0.3, 0.3, 0.3),\n\t\t\t[Roact.Event.MouseEnter] = function()\n\t\t\t\tgame:GetService("TweenService"):Create(btnRef:getValue(), TweenInfo.new(0.25), {\n\t\t\t\t\tBackgroundColor3 = Color3.new(0.3 * 0.75, 0.3 * 0.75, 0.3 * 0.75),\n\t\t\t\t}):Play()\n\t\t\tend,\n\t\t\t[Roact.Event.MouseLeave] = function()\n\t\t\t\tgame:GetService("TweenService"):Create(btnRef:getValue(), TweenInfo.new(0.25), {\n\t\t\t\t\tBackgroundColor3 = Color3.new(0.3, 0.3, 0.3),\n\t\t\t\t}):Play()\n\t\t\tend,\n\t\t\t[Roact.Event.MouseButton1Down] = function()\n\t\t\t\tlocal clkTween = game:GetService("TweenService"):Create(btnRef:getValue(), TweenInfo.new(0.075), {\n\t\t\t\t\tBackgroundColor3 = Color3.new(0.5, 0.5, 0.5),\n\t\t\t\t})\n\t\t\t\tclkTween:Play()\n\t\t\t\tclkTween.Completed:Connect(function()\n\t\t\t\t\tgame:GetService("TweenService"):Create(btnRef:getValue(), TweenInfo.new(0.075), {\n\t\t\t\t\t\tBackgroundColor3 = Color3.new(0.3, 0.3, 0.3),\n\t\t\t\t\t}):Play()\n\t\t\t\tend)\n\t\t\tend,\n\t\t\t[Roact.Event.MouseButton1Click] = function()\n\t\t\t\tif sfRef:getValue().Visible then\n\t\t\t\t\tsfRef:getValue().Visible = false\n\t\t\t\telse\n\t\t\t\t\tsfRef:getValue().Visible = true\n\t\t\t\tend\n\t\t\tend,\n\t\t}, {\n\t\t\tRoact.createElement("UIStroke", {\n\t\t\t\tThickness = 2,\n\t\t\t\tColor = Color3.new(0.15, 0.15, 0.15),\n\t\t\t\tApplyStrokeMode = Enum.ApplyStrokeMode.Border,\n\t\t\t}),\n\t\t\tRoact.createElement("UICorner", {\n\t\t\t\tCornerRadius = UDim.new(0.125, 0),\n\t\t\t}),\n\t\t}),\n\t\tRoact.createElement("ScrollingFrame", {\n\t\t\t[Roact.Ref] = sfRef,\n\t\t\tSize = UDim2.new(1, 0, 1, 0),\n\t\t\tBorderSizePixel = 0,\n\t\t\tScrollBarImageColor3 = Color3.new(1, 1, 1),\n\t\t\tBackgroundColor3 = Color3.new(0.3, 0.3, 0.3),\n\t\t\tScrollBarThickness = 6,\n\t\t\tAutomaticCanvasSize = Enum.AutomaticSize.Y,\n\t\t}, {\n\t\t\tRoact.createElement("UIStroke", {\n\t\t\t\tThickness = 2,\n\t\t\t\tColor = Color3.new(0.15, 0.15, 0.15),\n\t\t\t\tApplyStrokeMode = Enum.ApplyStrokeMode.Border,\n\t\t\t}),\n\t\t\tRoact.createElement("UICorner", {\n\t\t\t\tCornerRadius = UDim.new(0.125, 0),\n\t\t\t}),\n\t\t\tRoact.createElement("UIListLayout", {\n\t\t\t\tPadding = UDim.new(0, 2),\n\t\t\t}),\n\t\t}),\n\t})\nend)\nlocal function TeleportUI()\n\treturn Roact.createElement(Window)\nend\nreturn {\n\tTeleportUI = TeleportUI,\n}\n'
      }
    } },
  Properties = {
    ClassName = "Folder",
    Name = "Bundle"
  }
}